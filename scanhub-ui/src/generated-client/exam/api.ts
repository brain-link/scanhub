/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Exam base model.
 * @export
 * @interface BaseExam
 */
export interface BaseExam {
    /**
     * 
     * @type {string}
     * @memberof BaseExam
     */
    'patient_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseExam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseExam
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BaseExam
     */
    'indication'?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseExam
     */
    'patient_height_cm'?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseExam
     */
    'patient_weight_kg'?: number;
    /**
     * 
     * @type {string}
     * @memberof BaseExam
     */
    'comment'?: string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseExam
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof BaseExam
     */
    'is_template': boolean;
}


/**
 * Task model.
 * @export
 * @interface BaseTask
 */
export interface BaseTask {
    /**
     * 
     * @type {string}
     * @memberof BaseTask
     */
    'workflow_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseTask
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseTask
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BaseTask
     */
    'comment'?: string;
    /**
     * 
     * @type {TaskType}
     * @memberof BaseTask
     */
    'type': TaskType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BaseTask
     */
    'args': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BaseTask
     */
    'artifacts': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BaseTask
     */
    'destinations': { [key: string]: string; };
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseTask
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof BaseTask
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseTask
     */
    'is_template': boolean;
}


/**
 * Workflow base model.
 * @export
 * @interface BaseWorkflow
 */
export interface BaseWorkflow {
    /**
     * 
     * @type {string}
     * @memberof BaseWorkflow
     */
    'exam_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseWorkflow
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseWorkflow
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BaseWorkflow
     */
    'comment'?: string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseWorkflow
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof BaseWorkflow
     */
    'is_template': boolean;
}


/**
 * 
 * @export
 * @interface ExamId
 */
export interface ExamId {
}
/**
 * Exam output model.
 * @export
 * @interface ExamOut
 */
export interface ExamOut {
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'patient_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'indication'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamOut
     */
    'patient_height_cm'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExamOut
     */
    'patient_weight_kg'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'comment'?: string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ExamOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof ExamOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'datetime_updated'?: string;
    /**
     * 
     * @type {Array<WorkflowOut>}
     * @memberof ExamOut
     */
    'workflows': Array<WorkflowOut>;
}


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Task status enum.
 * @export
 * @enum {string}
 */

export const ItemStatus = {
    New: 'NEW',
    Updated: 'UPDATED',
    Started: 'STARTED',
    Finished: 'FINISHED',
    Deleted: 'DELETED'
} as const;

export type ItemStatus = typeof ItemStatus[keyof typeof ItemStatus];


/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface TaskId
 */
export interface TaskId {
}
/**
 * Task output model.
 * @export
 * @interface TaskOut
 */
export interface TaskOut {
    /**
     * 
     * @type {string}
     * @memberof TaskOut
     */
    'workflow_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOut
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOut
     */
    'comment'?: string;
    /**
     * 
     * @type {TaskType}
     * @memberof TaskOut
     */
    'type': TaskType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskOut
     */
    'args': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskOut
     */
    'artifacts': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskOut
     */
    'destinations': { [key: string]: string; };
    /**
     * 
     * @type {ItemStatus}
     * @memberof TaskOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof TaskOut
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof TaskOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof TaskOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOut
     */
    'datetime_updated'?: string;
}


/**
 * Task type enum.
 * @export
 * @enum {string}
 */

export const TaskType = {
    ProcessingTask: 'PROCESSING_TASK',
    DeviceTaskSimulator: 'DEVICE_TASK_SIMULATOR',
    DeviceTaskSdk: 'DEVICE_TASK_SDK',
    ReconstructionTask: 'RECONSTRUCTION_TASK'
} as const;

export type TaskType = typeof TaskType[keyof typeof TaskType];


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface WorkflowId
 */
export interface WorkflowId {
}
/**
 * Workflow output model.
 * @export
 * @interface WorkflowOut
 */
export interface WorkflowOut {
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'exam_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'comment'?: string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof WorkflowOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'datetime_updated'?: string;
    /**
     * 
     * @type {Array<TaskOut>}
     * @memberof WorkflowOut
     */
    'tasks': Array<TaskOut>;
}



/**
 * ExamsApi - axios parameter creator
 * @export
 */
export const ExamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamApiV1ExamNewPost: async (baseExam: BaseExam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseExam' is not null or undefined
            assertParamExists('createExamApiV1ExamNewPost', 'baseExam', baseExam)
            const localVarPath = `/api/v1/exam/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseExam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam From Template
         * @param {string} templateId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamFromTemplateApiV1ExamPost: async (templateId: string, baseExam: BaseExam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('createExamFromTemplateApiV1ExamPost', 'templateId', templateId)
            // verify required parameter 'baseExam' is not null or undefined
            assertParamExists('createExamFromTemplateApiV1ExamPost', 'baseExam', baseExam)
            const localVarPath = `/api/v1/exam/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseExam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Exam Delete
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examDeleteApiV1ExamExamIdDelete: async (examId: ExamId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('examDeleteApiV1ExamExamIdDelete', 'examId', examId)
            const localVarPath = `/api/v1/exam/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all exam templates.  Returns -------     List of exam pydantic output models
         * @summary Get All Exam Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamTemplatesApiV1ExamTemplatesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/templates/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
         * @summary Get All Patient Exams
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPatientExamsApiV1ExamAllPatientIdGet: async (patientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('getAllPatientExamsApiV1ExamAllPatientIdGet', 'patientId', patientId)
            const localVarPath = `/api/v1/exam/all/{patient_id}`
                .replace(`{${"patient_id"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
         * @summary Get Exam
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamApiV1ExamExamIdGet: async (examId: ExamId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('getExamApiV1ExamExamIdGet', 'examId', examId)
            const localVarPath = `/api/v1/exam/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Exam
         * @param {ExamId} examId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExamApiV1ExamExamIdPut: async (examId: ExamId, baseExam: BaseExam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('updateExamApiV1ExamExamIdPut', 'examId', examId)
            // verify required parameter 'baseExam' is not null or undefined
            assertParamExists('updateExamApiV1ExamExamIdPut', 'baseExam', baseExam)
            const localVarPath = `/api/v1/exam/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseExam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExamsApi - functional programming interface
 * @export
 */
export const ExamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExamApiV1ExamNewPost(baseExam: BaseExam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExamApiV1ExamNewPost(baseExam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.createExamApiV1ExamNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam From Template
         * @param {string} templateId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExamFromTemplateApiV1ExamPost(templateId: string, baseExam: BaseExam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExamFromTemplateApiV1ExamPost(templateId, baseExam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.createExamFromTemplateApiV1ExamPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Exam Delete
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examDeleteApiV1ExamExamIdDelete(examId: ExamId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examDeleteApiV1ExamExamIdDelete(examId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.examDeleteApiV1ExamExamIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all exam templates.  Returns -------     List of exam pydantic output models
         * @summary Get All Exam Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExamTemplatesApiV1ExamTemplatesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllExamTemplatesApiV1ExamTemplatesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.getAllExamTemplatesApiV1ExamTemplatesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
         * @summary Get All Patient Exams
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPatientExamsApiV1ExamAllPatientIdGet(patientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPatientExamsApiV1ExamAllPatientIdGet(patientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.getAllPatientExamsApiV1ExamAllPatientIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
         * @summary Get Exam
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExamApiV1ExamExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExamApiV1ExamExamIdGet(examId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.getExamApiV1ExamExamIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Exam
         * @param {ExamId} examId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExamApiV1ExamExamIdPut(examId: ExamId, baseExam: BaseExam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExamApiV1ExamExamIdPut(examId, baseExam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.updateExamApiV1ExamExamIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExamsApi - factory interface
 * @export
 */
export const ExamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExamsApiFp(configuration)
    return {
        /**
         * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamApiV1ExamNewPost(baseExam: BaseExam, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.createExamApiV1ExamNewPost(baseExam, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam From Template
         * @param {string} templateId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamFromTemplateApiV1ExamPost(templateId: string, baseExam: BaseExam, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.createExamFromTemplateApiV1ExamPost(templateId, baseExam, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Exam Delete
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examDeleteApiV1ExamExamIdDelete(examId: ExamId, options?: any): AxiosPromise<void> {
            return localVarFp.examDeleteApiV1ExamExamIdDelete(examId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all exam templates.  Returns -------     List of exam pydantic output models
         * @summary Get All Exam Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamTemplatesApiV1ExamTemplatesAllGet(options?: any): AxiosPromise<Array<ExamOut>> {
            return localVarFp.getAllExamTemplatesApiV1ExamTemplatesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
         * @summary Get All Patient Exams
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPatientExamsApiV1ExamAllPatientIdGet(patientId: string, options?: any): AxiosPromise<Array<ExamOut>> {
            return localVarFp.getAllPatientExamsApiV1ExamAllPatientIdGet(patientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
         * @summary Get Exam
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamApiV1ExamExamIdGet(examId: ExamId, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.getExamApiV1ExamExamIdGet(examId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Exam
         * @param {ExamId} examId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExamApiV1ExamExamIdPut(examId: ExamId, baseExam: BaseExam, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.updateExamApiV1ExamExamIdPut(examId, baseExam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExamsApi - object-oriented interface
 * @export
 * @class ExamsApi
 * @extends {BaseAPI}
 */
export class ExamsApi extends BaseAPI {
    /**
     * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Exam
     * @param {BaseExam} baseExam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public createExamApiV1ExamNewPost(baseExam: BaseExam, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).createExamApiV1ExamNewPost(baseExam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Exam From Template
     * @param {string} templateId 
     * @param {BaseExam} baseExam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public createExamFromTemplateApiV1ExamPost(templateId: string, baseExam: BaseExam, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).createExamFromTemplateApiV1ExamPost(templateId, baseExam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Exam Delete
     * @param {ExamId} examId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examDeleteApiV1ExamExamIdDelete(examId: ExamId, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examDeleteApiV1ExamExamIdDelete(examId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all exam templates.  Returns -------     List of exam pydantic output models
     * @summary Get All Exam Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public getAllExamTemplatesApiV1ExamTemplatesAllGet(options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).getAllExamTemplatesApiV1ExamTemplatesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
     * @summary Get All Patient Exams
     * @param {string} patientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public getAllPatientExamsApiV1ExamAllPatientIdGet(patientId: string, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).getAllPatientExamsApiV1ExamAllPatientIdGet(patientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
     * @summary Get Exam
     * @param {ExamId} examId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public getExamApiV1ExamExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).getExamApiV1ExamExamIdGet(examId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Exam
     * @param {ExamId} examId 
     * @param {BaseExam} baseExam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public updateExamApiV1ExamExamIdPut(examId: ExamId, baseExam: BaseExam, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).updateExamApiV1ExamExamIdPut(examId, baseExam, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Readiness health endpoint.  Returns -------     Status dictionary  Raises ------ HTTPException     500: Any of the exam-tree tables does not exist
         * @summary Readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessApiV1ExamHealthReadinessGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/health/readiness`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Readiness health endpoint.  Returns -------     Status dictionary  Raises ------ HTTPException     500: Any of the exam-tree tables does not exist
         * @summary Readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readinessApiV1ExamHealthReadinessGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readinessApiV1ExamHealthReadinessGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.readinessApiV1ExamHealthReadinessGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Readiness health endpoint.  Returns -------     Status dictionary  Raises ------ HTTPException     500: Any of the exam-tree tables does not exist
         * @summary Readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessApiV1ExamHealthReadinessGet(options?: any): AxiosPromise<any> {
            return localVarFp.readinessApiV1ExamHealthReadinessGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Readiness health endpoint.  Returns -------     Status dictionary  Raises ------ HTTPException     500: Any of the exam-tree tables does not exist
     * @summary Readiness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public readinessApiV1ExamHealthReadinessGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).readinessApiV1ExamHealthReadinessGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task
         * @param {BaseTask} baseTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskApiV1ExamTaskNewPost: async (baseTask: BaseTask, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseTask' is not null or undefined
            assertParamExists('createTaskApiV1ExamTaskNewPost', 'baseTask', baseTask)
            const localVarPath = `/api/v1/exam/task/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseTask, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task From Template
         * @param {string} workflowId 
         * @param {string} templateId 
         * @param {boolean} newTaskIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskFromTemplateApiV1ExamTaskPost: async (workflowId: string, templateId: string, newTaskIsTemplate: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('createTaskFromTemplateApiV1ExamTaskPost', 'workflowId', workflowId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('createTaskFromTemplateApiV1ExamTaskPost', 'templateId', templateId)
            // verify required parameter 'newTaskIsTemplate' is not null or undefined
            assertParamExists('createTaskFromTemplateApiV1ExamTaskPost', 'newTaskIsTemplate', newTaskIsTemplate)
            const localVarPath = `/api/v1/exam/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (workflowId !== undefined) {
                localVarQueryParameter['workflow_id'] = workflowId;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }

            if (newTaskIsTemplate !== undefined) {
                localVarQueryParameter['new_task_is_template'] = newTaskIsTemplate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskApiV1ExamTaskTaskIdDelete: async (taskId: TaskId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('deleteTaskApiV1ExamTaskTaskIdDelete', 'taskId', taskId)
            const localVarPath = `/api/v1/exam/task/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing task templates.  Returns -------     List of task pydantic output model
         * @summary Get All Task Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/task/templates/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
         * @summary Get All Workflow Tasks
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet: async (workflowId: WorkflowId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/exam/task/all/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskApiV1ExamTaskTaskIdGet: async (taskId: TaskId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTaskApiV1ExamTaskTaskIdGet', 'taskId', taskId)
            const localVarPath = `/api/v1/exam/task/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Task
         * @param {TaskId} taskId 
         * @param {BaseTask} baseTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskApiV1ExamTaskTaskIdPut: async (taskId: TaskId, baseTask: BaseTask, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('updateTaskApiV1ExamTaskTaskIdPut', 'taskId', taskId)
            // verify required parameter 'baseTask' is not null or undefined
            assertParamExists('updateTaskApiV1ExamTaskTaskIdPut', 'baseTask', baseTask)
            const localVarPath = `/api/v1/exam/task/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseTask, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task
         * @param {BaseTask} baseTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskApiV1ExamTaskNewPost(baseTask: BaseTask, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskApiV1ExamTaskNewPost(baseTask, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.createTaskApiV1ExamTaskNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task From Template
         * @param {string} workflowId 
         * @param {string} templateId 
         * @param {boolean} newTaskIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskFromTemplateApiV1ExamTaskPost(workflowId: string, templateId: string, newTaskIsTemplate: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskFromTemplateApiV1ExamTaskPost(workflowId, templateId, newTaskIsTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.createTaskFromTemplateApiV1ExamTaskPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskApiV1ExamTaskTaskIdDelete(taskId: TaskId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskApiV1ExamTaskTaskIdDelete(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.deleteTaskApiV1ExamTaskTaskIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing task templates.  Returns -------     List of task pydantic output model
         * @summary Get All Task Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
         * @summary Get All Workflow Tasks
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskApiV1ExamTaskTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskApiV1ExamTaskTaskIdGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getTaskApiV1ExamTaskTaskIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Task
         * @param {TaskId} taskId 
         * @param {BaseTask} baseTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaskApiV1ExamTaskTaskIdPut(taskId: TaskId, baseTask: BaseTask, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaskApiV1ExamTaskTaskIdPut(taskId, baseTask, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.updateTaskApiV1ExamTaskTaskIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task
         * @param {BaseTask} baseTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskApiV1ExamTaskNewPost(baseTask: BaseTask, options?: any): AxiosPromise<TaskOut> {
            return localVarFp.createTaskApiV1ExamTaskNewPost(baseTask, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task From Template
         * @param {string} workflowId 
         * @param {string} templateId 
         * @param {boolean} newTaskIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskFromTemplateApiV1ExamTaskPost(workflowId: string, templateId: string, newTaskIsTemplate: boolean, options?: any): AxiosPromise<TaskOut> {
            return localVarFp.createTaskFromTemplateApiV1ExamTaskPost(workflowId, templateId, newTaskIsTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskApiV1ExamTaskTaskIdDelete(taskId: TaskId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTaskApiV1ExamTaskTaskIdDelete(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing task templates.  Returns -------     List of task pydantic output model
         * @summary Get All Task Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options?: any): AxiosPromise<Array<TaskOut>> {
            return localVarFp.getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
         * @summary Get All Workflow Tasks
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId: WorkflowId, options?: any): AxiosPromise<Array<TaskOut>> {
            return localVarFp.getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskApiV1ExamTaskTaskIdGet(taskId: TaskId, options?: any): AxiosPromise<TaskOut> {
            return localVarFp.getTaskApiV1ExamTaskTaskIdGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Task
         * @param {TaskId} taskId 
         * @param {BaseTask} baseTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskApiV1ExamTaskTaskIdPut(taskId: TaskId, baseTask: BaseTask, options?: any): AxiosPromise<TaskOut> {
            return localVarFp.updateTaskApiV1ExamTaskTaskIdPut(taskId, baseTask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Task
     * @param {BaseTask} baseTask 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public createTaskApiV1ExamTaskNewPost(baseTask: BaseTask, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).createTaskApiV1ExamTaskNewPost(baseTask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Task From Template
     * @param {string} workflowId 
     * @param {string} templateId 
     * @param {boolean} newTaskIsTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public createTaskFromTemplateApiV1ExamTaskPost(workflowId: string, templateId: string, newTaskIsTemplate: boolean, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).createTaskFromTemplateApiV1ExamTaskPost(workflowId, templateId, newTaskIsTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Delete Task
     * @param {TaskId} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTaskApiV1ExamTaskTaskIdDelete(taskId: TaskId, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).deleteTaskApiV1ExamTaskTaskIdDelete(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing task templates.  Returns -------     List of task pydantic output model
     * @summary Get All Task Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
     * @summary Get All Workflow Tasks
     * @param {WorkflowId} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Get Task
     * @param {TaskId} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTaskApiV1ExamTaskTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTaskApiV1ExamTaskTaskIdGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Task
     * @param {TaskId} taskId 
     * @param {BaseTask} baseTask 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public updateTaskApiV1ExamTaskTaskIdPut(taskId: TaskId, baseTask: BaseTask, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).updateTaskApiV1ExamTaskTaskIdPut(taskId, baseTask, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowApiV1ExamWorkflowNewPost: async (baseWorkflow: BaseWorkflow, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseWorkflow' is not null or undefined
            assertParamExists('createWorkflowApiV1ExamWorkflowNewPost', 'baseWorkflow', baseWorkflow)
            const localVarPath = `/api/v1/exam/workflow/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseWorkflow, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow From Template
         * @param {string} examId 
         * @param {string} templateId 
         * @param {boolean} newWorkflowIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowFromTemplateApiV1ExamWorkflowPost: async (examId: string, templateId: string, newWorkflowIsTemplate: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('createWorkflowFromTemplateApiV1ExamWorkflowPost', 'examId', examId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('createWorkflowFromTemplateApiV1ExamWorkflowPost', 'templateId', templateId)
            // verify required parameter 'newWorkflowIsTemplate' is not null or undefined
            assertParamExists('createWorkflowFromTemplateApiV1ExamWorkflowPost', 'newWorkflowIsTemplate', newWorkflowIsTemplate)
            const localVarPath = `/api/v1/exam/workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (examId !== undefined) {
                localVarQueryParameter['exam_id'] = examId;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }

            if (newWorkflowIsTemplate !== undefined) {
                localVarQueryParameter['new_workflow_is_template'] = newWorkflowIsTemplate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete: async (workflowId: WorkflowId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete', 'workflowId', workflowId)
            const localVarPath = `/api/v1/exam/workflow/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
         * @summary Get All Exam Workflows
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet: async (examId: ExamId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet', 'examId', examId)
            const localVarPath = `/api/v1/exam/workflow/all/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all workflow templates.  Returns -------     List of workflow pydantic output model
         * @summary Get All Workflow Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/workflow/templates/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowApiV1ExamWorkflowWorkflowIdGet: async (workflowId: WorkflowId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowApiV1ExamWorkflowWorkflowIdGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/exam/workflow/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Workflow
         * @param {WorkflowId} workflowId 
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowApiV1ExamWorkflowWorkflowIdPut: async (workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('updateWorkflowApiV1ExamWorkflowWorkflowIdPut', 'workflowId', workflowId)
            // verify required parameter 'baseWorkflow' is not null or undefined
            assertParamExists('updateWorkflowApiV1ExamWorkflowWorkflowIdPut', 'baseWorkflow', baseWorkflow)
            const localVarPath = `/api/v1/exam/workflow/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseWorkflow, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflowApiV1ExamWorkflowNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow From Template
         * @param {string} examId 
         * @param {string} templateId 
         * @param {boolean} newWorkflowIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowFromTemplateApiV1ExamWorkflowPost(examId: string, templateId: string, newWorkflowIsTemplate: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowFromTemplateApiV1ExamWorkflowPost(examId, templateId, newWorkflowIsTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflowFromTemplateApiV1ExamWorkflowPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId: WorkflowId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
         * @summary Get All Exam Workflows
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all workflow templates.  Returns -------     List of workflow pydantic output model
         * @summary Get All Workflow Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getWorkflowApiV1ExamWorkflowWorkflowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Workflow
         * @param {WorkflowId} workflowId 
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId, baseWorkflow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.updateWorkflowApiV1ExamWorkflowWorkflowIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow: BaseWorkflow, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow From Template
         * @param {string} examId 
         * @param {string} templateId 
         * @param {boolean} newWorkflowIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowFromTemplateApiV1ExamWorkflowPost(examId: string, templateId: string, newWorkflowIsTemplate: boolean, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.createWorkflowFromTemplateApiV1ExamWorkflowPost(examId, templateId, newWorkflowIsTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId: WorkflowId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
         * @summary Get All Exam Workflows
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId: ExamId, options?: any): AxiosPromise<Array<WorkflowOut>> {
            return localVarFp.getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all workflow templates.  Returns -------     List of workflow pydantic output model
         * @summary Get All Workflow Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options?: any): AxiosPromise<Array<WorkflowOut>> {
            return localVarFp.getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId: WorkflowId, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Workflow
         * @param {WorkflowId} workflowId 
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId, baseWorkflow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Workflow
     * @param {BaseWorkflow} baseWorkflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Workflow From Template
     * @param {string} examId 
     * @param {string} templateId 
     * @param {boolean} newWorkflowIsTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowFromTemplateApiV1ExamWorkflowPost(examId: string, templateId: string, newWorkflowIsTemplate: boolean, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflowFromTemplateApiV1ExamWorkflowPost(examId, templateId, newWorkflowIsTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Delete Workflow
     * @param {WorkflowId} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId: WorkflowId, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
     * @summary Get All Exam Workflows
     * @param {ExamId} examId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all workflow templates.  Returns -------     List of workflow pydantic output model
     * @summary Get All Workflow Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Get Workflow
     * @param {WorkflowId} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Workflow
     * @param {WorkflowId} workflowId 
     * @param {BaseWorkflow} baseWorkflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId, baseWorkflow, options).then((request) => request(this.axios, this.basePath));
    }
}



