/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Pydantic definition of AcquisitionLimits.
 * @export
 * @interface AcquisitionLimits
 */
export interface AcquisitionLimits {
    /**
     * 
     * @type {number}
     * @memberof AcquisitionLimits
     */
    'patient_height': number;
    /**
     * 
     * @type {number}
     * @memberof AcquisitionLimits
     */
    'patient_weight': number;
    /**
     * 
     * @type {Gender}
     * @memberof AcquisitionLimits
     */
    'patient_gender'?: Gender;
    /**
     * 
     * @type {number}
     * @memberof AcquisitionLimits
     */
    'patient_age': number;
}


/**
 * Pydantic definition of acquisition parameters.
 * @export
 * @interface AcquisitionParameter
 */
export interface AcquisitionParameter {
    /**
     * 
     * @type {XYZ}
     * @memberof AcquisitionParameter
     */
    'fov_scaling'?: XYZ;
    /**
     * 
     * @type {XYZ}
     * @memberof AcquisitionParameter
     */
    'fov_offset'?: XYZ;
    /**
     * 
     * @type {XYZ}
     * @memberof AcquisitionParameter
     */
    'fov_rotation'?: XYZ;
}
/**
 * Acquisition Task output model.
 * @export
 * @interface AcquisitionTaskOut
 */
export interface AcquisitionTaskOut {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof AcquisitionTaskOut
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'description': string;
    /**
     * 
     * @type {TaskType}
     * @memberof AcquisitionTaskOut
     */
    'task_type': TaskType;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'destination': string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof AcquisitionTaskOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof AcquisitionTaskOut
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof AcquisitionTaskOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'device_id': string;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'sequence_id': string;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof AcquisitionTaskOut
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {AcquisitionLimits}
     * @memberof AcquisitionTaskOut
     */
    'acquisition_limits': AcquisitionLimits;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof AcquisitionTaskOut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {Array<ResultOut>}
     * @memberof AcquisitionTaskOut
     */
    'results': Array<ResultOut>;
}


/**
 * Represents a task for data acquisition in the system.
 * @export
 * @interface BaseAcquisitionTask
 */
export interface BaseAcquisitionTask {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof BaseAcquisitionTask
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'task_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'destination': string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseAcquisitionTask
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof BaseAcquisitionTask
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAcquisitionTask
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'device_id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'sequence_id': string;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof BaseAcquisitionTask
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {AcquisitionLimits}
     * @memberof BaseAcquisitionTask
     */
    'acquisition_limits': AcquisitionLimits;
}


/**
 * Workflow task model.  Attributes:     task_type (Literal[TaskType.DAG]): Specifies that this is a DAG task.     dag_type (TaskType): Type of the DAG (e.g., RECONSTRUCTION, PROCESSING).     dag_id (str): Unique identifier of the DAG.     input_result_id (UUID | None): Optional UUID of the input result.     parameter (dict | None): Optional dictionary of parameters for the DAG.  Example schema: {     \"task_type\": \"DAG\",     \"dag_type\": \"RECONSTRUCTION\",     \"dag_id\": \"recon-dag-001\",     \"input_result_id\": \"<result-uuid>\",     \"parameter\": {         \"threshold\": 0.01     } }
 * @export
 * @interface BaseDAGTask
 */
export interface BaseDAGTask {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof BaseDAGTask
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'task_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'destination': string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseDAGTask
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof BaseDAGTask
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseDAGTask
     */
    'is_template': boolean;
    /**
     * 
     * @type {TaskType}
     * @memberof BaseDAGTask
     */
    'dag_type': TaskType;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'dag_id': string;
    /**
     * 
     * @type {InputResultId}
     * @memberof BaseDAGTask
     */
    'input_result_id'?: InputResultId;
    /**
     * 
     * @type {Parameter}
     * @memberof BaseDAGTask
     */
    'parameter'?: Parameter;
}


/**
 * Exam base model.
 * @export
 * @interface BaseExam
 */
export interface BaseExam {
    /**
     * 
     * @type {PatientId}
     * @memberof BaseExam
     */
    'patient_id'?: PatientId;
    /**
     * 
     * @type {string}
     * @memberof BaseExam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseExam
     */
    'description': string;
    /**
     * 
     * @type {Indication}
     * @memberof BaseExam
     */
    'indication'?: Indication;
    /**
     * 
     * @type {PatientHeightCm}
     * @memberof BaseExam
     */
    'patient_height_cm'?: PatientHeightCm;
    /**
     * 
     * @type {PatientWeightKg}
     * @memberof BaseExam
     */
    'patient_weight_kg'?: PatientWeightKg;
    /**
     * 
     * @type {Comment}
     * @memberof BaseExam
     */
    'comment'?: Comment;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseExam
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof BaseExam
     */
    'is_template': boolean;
}


/**
 * Base model for MRI sequence.
 * @export
 * @interface BaseMRISequence
 */
export interface BaseMRISequence {
    /**
     * 
     * @type {string}
     * @memberof BaseMRISequence
     */
    'name': string;
    /**
     * 
     * @type {Description}
     * @memberof BaseMRISequence
     */
    'description'?: Description;
    /**
     * 
     * @type {SequenceType}
     * @memberof BaseMRISequence
     */
    'sequence_type'?: SequenceType;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseMRISequence
     */
    'tags'?: Array<string>;
}
/**
 * Result model.
 * @export
 * @interface BaseResult
 */
export interface BaseResult {
    /**
     * 
     * @type {TaskId1}
     * @memberof BaseResult
     */
    'task_id'?: TaskId1;
    /**
     * 
     * @type {ResultType}
     * @memberof BaseResult
     */
    'type': ResultType;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseResult
     */
    'status'?: ItemStatus;
    /**
     * 
     * @type {string}
     * @memberof BaseResult
     */
    'directory'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseResult
     */
    'filename'?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseResult
     */
    'progress'?: number;
}


/**
 * Workflow base model.
 * @export
 * @interface BaseWorkflow
 */
export interface BaseWorkflow {
    /**
     * 
     * @type {ExamId1}
     * @memberof BaseWorkflow
     */
    'exam_id'?: ExamId1;
    /**
     * 
     * @type {string}
     * @memberof BaseWorkflow
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseWorkflow
     */
    'description': string;
    /**
     * 
     * @type {Comment}
     * @memberof BaseWorkflow
     */
    'comment'?: Comment;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseWorkflow
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof BaseWorkflow
     */
    'is_template': boolean;
}


/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
}
/**
 * Workflow Task output model.
 * @export
 * @interface DAGTaskOut
 */
export interface DAGTaskOut {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof DAGTaskOut
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'description': string;
    /**
     * 
     * @type {TaskType}
     * @memberof DAGTaskOut
     */
    'task_type': TaskType;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'destination': string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof DAGTaskOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof DAGTaskOut
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof DAGTaskOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {TaskType}
     * @memberof DAGTaskOut
     */
    'dag_type': TaskType;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'dag_id': string;
    /**
     * 
     * @type {InputResultId}
     * @memberof DAGTaskOut
     */
    'input_result_id'?: InputResultId;
    /**
     * 
     * @type {Parameter}
     * @memberof DAGTaskOut
     */
    'parameter'?: Parameter;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof DAGTaskOut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {Array<ResultOut>}
     * @memberof DAGTaskOut
     */
    'results': Array<ResultOut>;
}


/**
 * 
 * @export
 * @interface DatetimeUpdated
 */
export interface DatetimeUpdated {
}
/**
 * 
 * @export
 * @interface Description
 */
export interface Description {
}
/**
 * 
 * @export
 * @interface ExamId
 */
export interface ExamId {
}
/**
 * 
 * @export
 * @interface ExamId1
 */
export interface ExamId1 {
}
/**
 * Exam output model.
 * @export
 * @interface ExamOut
 */
export interface ExamOut {
    /**
     * 
     * @type {PatientId}
     * @memberof ExamOut
     */
    'patient_id'?: PatientId;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'description': string;
    /**
     * 
     * @type {Indication}
     * @memberof ExamOut
     */
    'indication'?: Indication;
    /**
     * 
     * @type {PatientHeightCm}
     * @memberof ExamOut
     */
    'patient_height_cm'?: PatientHeightCm;
    /**
     * 
     * @type {PatientWeightKg}
     * @memberof ExamOut
     */
    'patient_weight_kg'?: PatientWeightKg;
    /**
     * 
     * @type {Comment}
     * @memberof ExamOut
     */
    'comment'?: Comment;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ExamOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof ExamOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ExamOut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {Array<WorkflowOut>}
     * @memberof ExamOut
     */
    'workflows': Array<WorkflowOut>;
}


/**
 * 
 * @export
 * @interface FileExtension
 */
export interface FileExtension {
}
/**
 * Pydantic definition of genders.
 * @export
 * @enum {string}
 */

export const Gender = {
    Male: 'MALE',
    Female: 'FEMALE',
    Other: 'OTHER',
    NotGiven: 'NOT_GIVEN'
} as const;

export type Gender = typeof Gender[keyof typeof Gender];


/**
 * 
 * @export
 * @interface GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
 */
export interface GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'is_template': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'device_id': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {AcquisitionLimits}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'acquisition_limits': AcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'results': any;
    /**
     * 
     * @type {TaskType}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'dag_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'dag_id': any;
    /**
     * 
     * @type {InputResultId}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'input_result_id'?: InputResultId;
    /**
     * 
     * @type {Parameter}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'parameter'?: Parameter;
}


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Indication
 */
export interface Indication {
}
/**
 * 
 * @export
 * @interface InputResultId
 */
export interface InputResultId {
}
/**
 * Task status enum.
 * @export
 * @enum {string}
 */

export const ItemStatus = {
    New: 'NEW',
    Updated: 'UPDATED',
    Started: 'STARTED',
    Finished: 'FINISHED',
    Deleted: 'DELETED',
    Inprogress: 'INPROGRESS'
} as const;

export type ItemStatus = typeof ItemStatus[keyof typeof ItemStatus];


/**
 * Output model for MRI sequence.
 * @export
 * @interface MRISequenceOut
 */
export interface MRISequenceOut {
    /**
     * 
     * @type {string}
     * @memberof MRISequenceOut
     */
    'name': string;
    /**
     * 
     * @type {Description}
     * @memberof MRISequenceOut
     */
    'description'?: Description;
    /**
     * 
     * @type {SequenceType}
     * @memberof MRISequenceOut
     */
    'sequence_type'?: SequenceType;
    /**
     * 
     * @type {Array<string>}
     * @memberof MRISequenceOut
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MRISequenceOut
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof MRISequenceOut
     */
    'created_at': string;
    /**
     * 
     * @type {UpdatedAt}
     * @memberof MRISequenceOut
     */
    'updated_at'?: UpdatedAt;
    /**
     * 
     * @type {any}
     * @memberof MRISequenceOut
     */
    'file': any;
    /**
     * 
     * @type {FileExtension}
     * @memberof MRISequenceOut
     */
    'file_extension'?: FileExtension;
}
/**
 * 
 * @export
 * @interface Parameter
 */
export interface Parameter {
}
/**
 * 
 * @export
 * @interface PatientHeightCm
 */
export interface PatientHeightCm {
}
/**
 * 
 * @export
 * @interface PatientId
 */
export interface PatientId {
}
/**
 * 
 * @export
 * @interface PatientWeightKg
 */
export interface PatientWeightKg {
}
/**
 * @type Payload
 * @export
 */
export type Payload = { task_type: 'ACQUISITION' } & BaseAcquisitionTask | { task_type: 'DAG' } & BaseDAGTask;

/**
 * 
 * @export
 * @interface ResponseCreateTaskApiV1ExamTaskNewPost
 */
export interface ResponseCreateTaskApiV1ExamTaskNewPost {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'is_template': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'device_id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {AcquisitionLimits}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'acquisition_limits': AcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'results': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'dag_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'dag_id': any;
    /**
     * 
     * @type {InputResultId}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'input_result_id'?: InputResultId;
    /**
     * 
     * @type {Parameter}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'parameter'?: Parameter;
}


/**
 * 
 * @export
 * @interface ResponseCreateTaskFromTemplateApiV1ExamTaskPost
 */
export interface ResponseCreateTaskFromTemplateApiV1ExamTaskPost {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'is_template': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'device_id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {AcquisitionLimits}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'acquisition_limits': AcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'results': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'dag_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'dag_id': any;
    /**
     * 
     * @type {InputResultId}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'input_result_id'?: InputResultId;
    /**
     * 
     * @type {Parameter}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'parameter'?: Parameter;
}


/**
 * 
 * @export
 * @interface ResponseGetTaskApiV1ExamTaskTaskIdGet
 */
export interface ResponseGetTaskApiV1ExamTaskTaskIdGet {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'is_template': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'device_id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {AcquisitionLimits}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'acquisition_limits': AcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'results': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'dag_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'dag_id': any;
    /**
     * 
     * @type {InputResultId}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'input_result_id'?: InputResultId;
    /**
     * 
     * @type {Parameter}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'parameter'?: Parameter;
}


/**
 * 
 * @export
 * @interface ResponseUpdateTaskApiV1ExamTaskTaskIdPut
 */
export interface ResponseUpdateTaskApiV1ExamTaskTaskIdPut {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'is_template': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'device_id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {AcquisitionLimits}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'acquisition_limits': AcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'results': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'dag_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'dag_id': any;
    /**
     * 
     * @type {InputResultId}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'input_result_id'?: InputResultId;
    /**
     * 
     * @type {Parameter}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'parameter'?: Parameter;
}


/**
 * 
 * @export
 * @interface ResultId
 */
export interface ResultId {
}
/**
 * Result output model.
 * @export
 * @interface ResultOut
 */
export interface ResultOut {
    /**
     * 
     * @type {TaskId1}
     * @memberof ResultOut
     */
    'task_id'?: TaskId1;
    /**
     * 
     * @type {ResultType}
     * @memberof ResultOut
     */
    'type': ResultType;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ResultOut
     */
    'status'?: ItemStatus;
    /**
     * 
     * @type {string}
     * @memberof ResultOut
     */
    'directory'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResultOut
     */
    'filename'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResultOut
     */
    'progress'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResultOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResultOut
     */
    'datetime_created': string;
}


/**
 * Result type enum.
 * @export
 * @enum {string}
 */

export const ResultType = {
    Dicom: 'DICOM',
    Mrd: 'MRD',
    Calibration: 'CALIBRATION'
} as const;

export type ResultType = typeof ResultType[keyof typeof ResultType];


/**
 * 
 * @export
 * @interface SequenceType
 */
export interface SequenceType {
}
/**
 * 
 * @export
 * @interface TaskId
 */
export interface TaskId {
}
/**
 * 
 * @export
 * @interface TaskId1
 */
export interface TaskId1 {
}
/**
 * Task type enum.
 * @export
 * @enum {string}
 */

export const TaskType = {
    Acquisition: 'ACQUISITION',
    Dag: 'DAG',
    Reconstruction: 'RECONSTRUCTION',
    Processing: 'PROCESSING'
} as const;

export type TaskType = typeof TaskType[keyof typeof TaskType];


/**
 * 
 * @export
 * @interface UpdatedAt
 */
export interface UpdatedAt {
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * 
 * @export
 * @interface WorkflowId
 */
export interface WorkflowId {
}
/**
 * 
 * @export
 * @interface WorkflowId1
 */
export interface WorkflowId1 {
}
/**
 * Workflow output model.
 * @export
 * @interface WorkflowOut
 */
export interface WorkflowOut {
    /**
     * 
     * @type {ExamId1}
     * @memberof WorkflowOut
     */
    'exam_id'?: ExamId1;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'description': string;
    /**
     * 
     * @type {Comment}
     * @memberof WorkflowOut
     */
    'comment'?: Comment;
    /**
     * 
     * @type {ItemStatus}
     * @memberof WorkflowOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof WorkflowOut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>}
     * @memberof WorkflowOut
     */
    'tasks': Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>;
}


/**
 * Pydantic definition of coordinates.
 * @export
 * @interface XYZ
 */
export interface XYZ {
    /**
     * 
     * @type {number}
     * @memberof XYZ
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof XYZ
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof XYZ
     */
    'z': number;
}

/**
 * ExamsApi - axios parameter creator
 * @export
 */
export const ExamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamApiV1ExamNewPost: async (baseExam: BaseExam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseExam' is not null or undefined
            assertParamExists('createExamApiV1ExamNewPost', 'baseExam', baseExam)
            const localVarPath = `/api/v1/exam/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseExam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam From Template
         * @param {string} templateId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamFromTemplateApiV1ExamPost: async (templateId: string, baseExam: BaseExam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('createExamFromTemplateApiV1ExamPost', 'templateId', templateId)
            // verify required parameter 'baseExam' is not null or undefined
            assertParamExists('createExamFromTemplateApiV1ExamPost', 'baseExam', baseExam)
            const localVarPath = `/api/v1/exam/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseExam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Exam Delete
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examDeleteApiV1ExamExamIdDelete: async (examId: ExamId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('examDeleteApiV1ExamExamIdDelete', 'examId', examId)
            const localVarPath = `/api/v1/exam/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all exam templates.  Returns -------     List of exam pydantic output models
         * @summary Get All Exam Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamTemplatesApiV1ExamTemplatesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/templates/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
         * @summary Get All Patient Exams
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPatientExamsApiV1ExamAllPatientIdGet: async (patientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('getAllPatientExamsApiV1ExamAllPatientIdGet', 'patientId', patientId)
            const localVarPath = `/api/v1/exam/all/{patient_id}`
                .replace(`{${"patient_id"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
         * @summary Get Exam
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamApiV1ExamExamIdGet: async (examId: ExamId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('getExamApiV1ExamExamIdGet', 'examId', examId)
            const localVarPath = `/api/v1/exam/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Exam
         * @param {ExamId} examId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExamApiV1ExamExamIdPut: async (examId: ExamId, baseExam: BaseExam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('updateExamApiV1ExamExamIdPut', 'examId', examId)
            // verify required parameter 'baseExam' is not null or undefined
            assertParamExists('updateExamApiV1ExamExamIdPut', 'baseExam', baseExam)
            const localVarPath = `/api/v1/exam/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseExam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExamsApi - functional programming interface
 * @export
 */
export const ExamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExamApiV1ExamNewPost(baseExam: BaseExam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExamApiV1ExamNewPost(baseExam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.createExamApiV1ExamNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam From Template
         * @param {string} templateId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExamFromTemplateApiV1ExamPost(templateId: string, baseExam: BaseExam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExamFromTemplateApiV1ExamPost(templateId, baseExam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.createExamFromTemplateApiV1ExamPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Exam Delete
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examDeleteApiV1ExamExamIdDelete(examId: ExamId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examDeleteApiV1ExamExamIdDelete(examId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.examDeleteApiV1ExamExamIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all exam templates.  Returns -------     List of exam pydantic output models
         * @summary Get All Exam Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExamTemplatesApiV1ExamTemplatesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllExamTemplatesApiV1ExamTemplatesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.getAllExamTemplatesApiV1ExamTemplatesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
         * @summary Get All Patient Exams
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPatientExamsApiV1ExamAllPatientIdGet(patientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPatientExamsApiV1ExamAllPatientIdGet(patientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.getAllPatientExamsApiV1ExamAllPatientIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
         * @summary Get Exam
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExamApiV1ExamExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExamApiV1ExamExamIdGet(examId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.getExamApiV1ExamExamIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Exam
         * @param {ExamId} examId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExamApiV1ExamExamIdPut(examId: ExamId, baseExam: BaseExam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExamApiV1ExamExamIdPut(examId, baseExam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.updateExamApiV1ExamExamIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExamsApi - factory interface
 * @export
 */
export const ExamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExamsApiFp(configuration)
    return {
        /**
         * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamApiV1ExamNewPost(baseExam: BaseExam, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.createExamApiV1ExamNewPost(baseExam, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam From Template
         * @param {string} templateId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamFromTemplateApiV1ExamPost(templateId: string, baseExam: BaseExam, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.createExamFromTemplateApiV1ExamPost(templateId, baseExam, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Exam Delete
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examDeleteApiV1ExamExamIdDelete(examId: ExamId, options?: any): AxiosPromise<void> {
            return localVarFp.examDeleteApiV1ExamExamIdDelete(examId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all exam templates.  Returns -------     List of exam pydantic output models
         * @summary Get All Exam Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamTemplatesApiV1ExamTemplatesAllGet(options?: any): AxiosPromise<Array<ExamOut>> {
            return localVarFp.getAllExamTemplatesApiV1ExamTemplatesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
         * @summary Get All Patient Exams
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPatientExamsApiV1ExamAllPatientIdGet(patientId: string, options?: any): AxiosPromise<Array<ExamOut>> {
            return localVarFp.getAllPatientExamsApiV1ExamAllPatientIdGet(patientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
         * @summary Get Exam
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamApiV1ExamExamIdGet(examId: ExamId, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.getExamApiV1ExamExamIdGet(examId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Exam
         * @param {ExamId} examId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExamApiV1ExamExamIdPut(examId: ExamId, baseExam: BaseExam, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.updateExamApiV1ExamExamIdPut(examId, baseExam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExamsApi - object-oriented interface
 * @export
 * @class ExamsApi
 * @extends {BaseAPI}
 */
export class ExamsApi extends BaseAPI {
    /**
     * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Exam
     * @param {BaseExam} baseExam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public createExamApiV1ExamNewPost(baseExam: BaseExam, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).createExamApiV1ExamNewPost(baseExam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Exam From Template
     * @param {string} templateId 
     * @param {BaseExam} baseExam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public createExamFromTemplateApiV1ExamPost(templateId: string, baseExam: BaseExam, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).createExamFromTemplateApiV1ExamPost(templateId, baseExam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Exam Delete
     * @param {ExamId} examId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examDeleteApiV1ExamExamIdDelete(examId: ExamId, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examDeleteApiV1ExamExamIdDelete(examId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all exam templates.  Returns -------     List of exam pydantic output models
     * @summary Get All Exam Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public getAllExamTemplatesApiV1ExamTemplatesAllGet(options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).getAllExamTemplatesApiV1ExamTemplatesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
     * @summary Get All Patient Exams
     * @param {string} patientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public getAllPatientExamsApiV1ExamAllPatientIdGet(patientId: string, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).getAllPatientExamsApiV1ExamAllPatientIdGet(patientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
     * @summary Get Exam
     * @param {ExamId} examId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public getExamApiV1ExamExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).getExamApiV1ExamExamIdGet(examId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Exam
     * @param {ExamId} examId 
     * @param {BaseExam} baseExam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public updateExamApiV1ExamExamIdPut(examId: ExamId, baseExam: BaseExam, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).updateExamApiV1ExamExamIdPut(examId, baseExam, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Readiness health endpoint.  Returns -------     Status dictionary  Raises ------ HTTPException     500: Any of the exam-tree tables does not exist
         * @summary Readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessApiV1ExamHealthReadinessGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/health/readiness`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Readiness health endpoint.  Returns -------     Status dictionary  Raises ------ HTTPException     500: Any of the exam-tree tables does not exist
         * @summary Readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readinessApiV1ExamHealthReadinessGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readinessApiV1ExamHealthReadinessGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.readinessApiV1ExamHealthReadinessGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Readiness health endpoint.  Returns -------     Status dictionary  Raises ------ HTTPException     500: Any of the exam-tree tables does not exist
         * @summary Readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessApiV1ExamHealthReadinessGet(options?: any): AxiosPromise<any> {
            return localVarFp.readinessApiV1ExamHealthReadinessGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Readiness health endpoint.  Returns -------     Status dictionary  Raises ------ HTTPException     500: Any of the exam-tree tables does not exist
     * @summary Readiness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public readinessApiV1ExamHealthReadinessGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).readinessApiV1ExamHealthReadinessGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MriSequencesApi - axios parameter creator
 * @export
 */
export const MriSequencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload an MRI sequence file and store it with the provided metadata.  Parameters ---------- mri_sequence : MRISequenceCreate     The MRI sequence metadata. file : UploadFile     The MRI sequence file to store. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The stored MRI sequence with the uploaded file.
         * @summary Create Mri Sequence
         * @param {File} file 
         * @param {string} name 
         * @param {string} [description] 
         * @param {string} [sequenceType] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMriSequenceApiV1ExamSequencePost: async (file: File, name: string, description?: string, sequenceType?: string, tags?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createMriSequenceApiV1ExamSequencePost', 'file', file)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createMriSequenceApiV1ExamSequencePost', 'name', name)
            const localVarPath = `/api/v1/exam/sequence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (sequenceType !== undefined) { 
                localVarFormParams.append('sequence_type', sequenceType as any);
            }
                if (tags) {
                localVarFormParams.append('tags', tags.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to delete. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- None
         * @summary Delete Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete: async (sequenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            assertParamExists('deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete', 'sequenceId', sequenceId)
            const localVarPath = `/api/v1/exam/sequence/{sequence_id}`
                .replace(`{${"sequence_id"}}`, encodeURIComponent(String(sequenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all MRI sequences from the database.  Parameters ---------- database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- List[MRISequence]     The list of MRI sequences.
         * @summary Get All Mri Sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMriSequencesApiV1ExamSequencesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/sequences/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The retrieved MRI sequence.
         * @summary Get Mri Sequence By Id
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMriSequenceByIdApiV1ExamSequenceSequenceIdGet: async (sequenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            assertParamExists('getMriSequenceByIdApiV1ExamSequenceSequenceIdGet', 'sequenceId', sequenceId)
            const localVarPath = `/api/v1/exam/sequence/{sequence_id}`
                .replace(`{${"sequence_id"}}`, encodeURIComponent(String(sequenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an MRI sequence file by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. background_tasks : BackgroundTasks     The background tasks to run. name : str     The name of the file to download. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- FileResponse     The retrieved MRI sequence file.
         * @summary Get Mri Sequence File By Id
         * @param {string} sequenceId 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet: async (sequenceId: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            assertParamExists('getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet', 'sequenceId', sequenceId)
            const localVarPath = `/api/v1/exam/sequence/{sequence_id}/file`
                .replace(`{${"sequence_id"}}`, encodeURIComponent(String(sequenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an MRI sequence with new data.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to update. mri_sequence : MRISequence     The updated MRI sequence data. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The updated MRI sequence.
         * @summary Update Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {BaseMRISequence} baseMRISequence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut: async (sequenceId: string, baseMRISequence: BaseMRISequence, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            assertParamExists('updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut', 'sequenceId', sequenceId)
            // verify required parameter 'baseMRISequence' is not null or undefined
            assertParamExists('updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut', 'baseMRISequence', baseMRISequence)
            const localVarPath = `/api/v1/exam/sequence/{sequence_id}`
                .replace(`{${"sequence_id"}}`, encodeURIComponent(String(sequenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseMRISequence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MriSequencesApi - functional programming interface
 * @export
 */
export const MriSequencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MriSequencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload an MRI sequence file and store it with the provided metadata.  Parameters ---------- mri_sequence : MRISequenceCreate     The MRI sequence metadata. file : UploadFile     The MRI sequence file to store. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The stored MRI sequence with the uploaded file.
         * @summary Create Mri Sequence
         * @param {File} file 
         * @param {string} name 
         * @param {string} [description] 
         * @param {string} [sequenceType] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMriSequenceApiV1ExamSequencePost(file: File, name: string, description?: string, sequenceType?: string, tags?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MRISequenceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMriSequenceApiV1ExamSequencePost(file, name, description, sequenceType, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.createMriSequenceApiV1ExamSequencePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to delete. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- None
         * @summary Delete Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all MRI sequences from the database.  Parameters ---------- database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- List[MRISequence]     The list of MRI sequences.
         * @summary Get All Mri Sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMriSequencesApiV1ExamSequencesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MRISequenceOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMriSequencesApiV1ExamSequencesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.getAllMriSequencesApiV1ExamSequencesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The retrieved MRI sequence.
         * @summary Get Mri Sequence By Id
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MRISequenceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.getMriSequenceByIdApiV1ExamSequenceSequenceIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an MRI sequence file by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. background_tasks : BackgroundTasks     The background tasks to run. name : str     The name of the file to download. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- FileResponse     The retrieved MRI sequence file.
         * @summary Get Mri Sequence File By Id
         * @param {string} sequenceId 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an MRI sequence with new data.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to update. mri_sequence : MRISequence     The updated MRI sequence data. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The updated MRI sequence.
         * @summary Update Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {BaseMRISequence} baseMRISequence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId: string, baseMRISequence: BaseMRISequence, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MRISequenceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId, baseMRISequence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MriSequencesApi - factory interface
 * @export
 */
export const MriSequencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MriSequencesApiFp(configuration)
    return {
        /**
         * Upload an MRI sequence file and store it with the provided metadata.  Parameters ---------- mri_sequence : MRISequenceCreate     The MRI sequence metadata. file : UploadFile     The MRI sequence file to store. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The stored MRI sequence with the uploaded file.
         * @summary Create Mri Sequence
         * @param {File} file 
         * @param {string} name 
         * @param {string} [description] 
         * @param {string} [sequenceType] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMriSequenceApiV1ExamSequencePost(file: File, name: string, description?: string, sequenceType?: string, tags?: Array<string>, options?: any): AxiosPromise<MRISequenceOut> {
            return localVarFp.createMriSequenceApiV1ExamSequencePost(file, name, description, sequenceType, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to delete. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- None
         * @summary Delete Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all MRI sequences from the database.  Parameters ---------- database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- List[MRISequence]     The list of MRI sequences.
         * @summary Get All Mri Sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMriSequencesApiV1ExamSequencesAllGet(options?: any): AxiosPromise<Array<MRISequenceOut>> {
            return localVarFp.getAllMriSequencesApiV1ExamSequencesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The retrieved MRI sequence.
         * @summary Get Mri Sequence By Id
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId: string, options?: any): AxiosPromise<MRISequenceOut> {
            return localVarFp.getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an MRI sequence file by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. background_tasks : BackgroundTasks     The background tasks to run. name : str     The name of the file to download. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- FileResponse     The retrieved MRI sequence file.
         * @summary Get Mri Sequence File By Id
         * @param {string} sequenceId 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId: string, name?: string, options?: any): AxiosPromise<any> {
            return localVarFp.getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an MRI sequence with new data.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to update. mri_sequence : MRISequence     The updated MRI sequence data. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The updated MRI sequence.
         * @summary Update Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {BaseMRISequence} baseMRISequence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId: string, baseMRISequence: BaseMRISequence, options?: any): AxiosPromise<MRISequenceOut> {
            return localVarFp.updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId, baseMRISequence, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MriSequencesApi - object-oriented interface
 * @export
 * @class MriSequencesApi
 * @extends {BaseAPI}
 */
export class MriSequencesApi extends BaseAPI {
    /**
     * Upload an MRI sequence file and store it with the provided metadata.  Parameters ---------- mri_sequence : MRISequenceCreate     The MRI sequence metadata. file : UploadFile     The MRI sequence file to store. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The stored MRI sequence with the uploaded file.
     * @summary Create Mri Sequence
     * @param {File} file 
     * @param {string} name 
     * @param {string} [description] 
     * @param {string} [sequenceType] 
     * @param {Array<string>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public createMriSequenceApiV1ExamSequencePost(file: File, name: string, description?: string, sequenceType?: string, tags?: Array<string>, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).createMriSequenceApiV1ExamSequencePost(file, name, description, sequenceType, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to delete. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- None
     * @summary Delete Mri Sequence Endpoint
     * @param {string} sequenceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId: string, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all MRI sequences from the database.  Parameters ---------- database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- List[MRISequence]     The list of MRI sequences.
     * @summary Get All Mri Sequences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public getAllMriSequencesApiV1ExamSequencesAllGet(options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).getAllMriSequencesApiV1ExamSequencesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The retrieved MRI sequence.
     * @summary Get Mri Sequence By Id
     * @param {string} sequenceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId: string, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an MRI sequence file by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. background_tasks : BackgroundTasks     The background tasks to run. name : str     The name of the file to download. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- FileResponse     The retrieved MRI sequence file.
     * @summary Get Mri Sequence File By Id
     * @param {string} sequenceId 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId: string, name?: string, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an MRI sequence with new data.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to update. mri_sequence : MRISequence     The updated MRI sequence data. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The updated MRI sequence.
     * @summary Update Mri Sequence Endpoint
     * @param {string} sequenceId 
     * @param {BaseMRISequence} baseMRISequence 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId: string, baseMRISequence: BaseMRISequence, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId, baseMRISequence, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResultsApi - axios parameter creator
 * @export
 */
export const ResultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a task result.  Parameters ---------- payload     Result pydantic input model  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Result
         * @param {BaseResult} baseResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResultApiV1ExamResultPost: async (baseResult: BaseResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseResult' is not null or undefined
            assertParamExists('createResultApiV1ExamResultPost', 'baseResult', baseResult)
            const localVarPath = `/api/v1/exam/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResultApiV1ExamResultResultIdDelete: async (resultId: ResultId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('deleteResultApiV1ExamResultResultIdDelete', 'resultId', resultId)
            const localVarPath = `/api/v1/exam/result/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing results of a certain task.  Parameters ---------- task_id     Id of parental task  Returns -------     List of task pydantic output model
         * @summary Get All Task Results
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskResultsApiV1ExamResultAllTaskIdGet: async (taskId: TaskId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getAllTaskResultsApiV1ExamResultAllTaskIdGet', 'taskId', taskId)
            const localVarPath = `/api/v1/exam/result/all/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get DICOM file of a result.  This endpoint in implemented in main without the result_router to omit the user authentification. The frontend uses cornerstone to load the image, which would need to know, how to authenticate with the backend. This is not to be done. TODO fix it!  Parameters ---------- result_id     UUID of the result with the dicom.  Returns -------     DICOM file response  Raises ------ HTTPException     Throws exception if result ID is unknown HTTPException     Throws exception if DICOM file does not exist
         * @summary Get Dicom
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDicomApiV1ExamDicomResultIdGet: async (resultId: ResultId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getDicomApiV1ExamDicomResultIdGet', 'resultId', resultId)
            const localVarPath = `/api/v1/exam/dicom/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing result.  Parameters ---------- result_id     Id of the result to be returned  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResultApiV1ExamResultResultIdGet: async (resultId: ResultId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getResultApiV1ExamResultResultIdGet', 'resultId', resultId)
            const localVarPath = `/api/v1/exam/result/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing result.  Parameters ---------- result_id     Id of the result to be updated payload     Result pydantic base model/dict     If this is the pydantic ResultBase model, only fields in the base model can be updated.  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Result
         * @param {ResultId} resultId 
         * @param {BaseResult} baseResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResultApiV1ExamResultResultIdPut: async (resultId: ResultId, baseResult: BaseResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('updateResultApiV1ExamResultResultIdPut', 'resultId', resultId)
            // verify required parameter 'baseResult' is not null or undefined
            assertParamExists('updateResultApiV1ExamResultResultIdPut', 'baseResult', baseResult)
            const localVarPath = `/api/v1/exam/result/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a DICOM file to a result.  Parameters ---------- result_id     UUID of the result file     Dicom file user     User for authentification  Raises ------ HTTPException     Throws error if ID of the result is unknown
         * @summary Upload Dicom
         * @param {ResultId} resultId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDicomApiV1ExamDicomResultIdPost: async (resultId: ResultId, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('uploadDicomApiV1ExamDicomResultIdPost', 'resultId', resultId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDicomApiV1ExamDicomResultIdPost', 'file', file)
            const localVarPath = `/api/v1/exam/dicom/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResultsApi - functional programming interface
 * @export
 */
export const ResultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResultsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a task result.  Parameters ---------- payload     Result pydantic input model  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Result
         * @param {BaseResult} baseResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResultApiV1ExamResultPost(baseResult: BaseResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResultApiV1ExamResultPost(baseResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.createResultApiV1ExamResultPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResultApiV1ExamResultResultIdDelete(resultId: ResultId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResultApiV1ExamResultResultIdDelete(resultId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.deleteResultApiV1ExamResultResultIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing results of a certain task.  Parameters ---------- task_id     Id of parental task  Returns -------     List of task pydantic output model
         * @summary Get All Task Results
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResultOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.getAllTaskResultsApiV1ExamResultAllTaskIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get DICOM file of a result.  This endpoint in implemented in main without the result_router to omit the user authentification. The frontend uses cornerstone to load the image, which would need to know, how to authenticate with the backend. This is not to be done. TODO fix it!  Parameters ---------- result_id     UUID of the result with the dicom.  Returns -------     DICOM file response  Raises ------ HTTPException     Throws exception if result ID is unknown HTTPException     Throws exception if DICOM file does not exist
         * @summary Get Dicom
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDicomApiV1ExamDicomResultIdGet(resultId: ResultId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDicomApiV1ExamDicomResultIdGet(resultId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.getDicomApiV1ExamDicomResultIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an existing result.  Parameters ---------- result_id     Id of the result to be returned  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResultApiV1ExamResultResultIdGet(resultId: ResultId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResultApiV1ExamResultResultIdGet(resultId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.getResultApiV1ExamResultResultIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing result.  Parameters ---------- result_id     Id of the result to be updated payload     Result pydantic base model/dict     If this is the pydantic ResultBase model, only fields in the base model can be updated.  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Result
         * @param {ResultId} resultId 
         * @param {BaseResult} baseResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResultApiV1ExamResultResultIdPut(resultId: ResultId, baseResult: BaseResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResultApiV1ExamResultResultIdPut(resultId, baseResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.updateResultApiV1ExamResultResultIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a DICOM file to a result.  Parameters ---------- result_id     UUID of the result file     Dicom file user     User for authentification  Raises ------ HTTPException     Throws error if ID of the result is unknown
         * @summary Upload Dicom
         * @param {ResultId} resultId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDicomApiV1ExamDicomResultIdPost(resultId: ResultId, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDicomApiV1ExamDicomResultIdPost(resultId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.uploadDicomApiV1ExamDicomResultIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResultsApi - factory interface
 * @export
 */
export const ResultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResultsApiFp(configuration)
    return {
        /**
         * Create a task result.  Parameters ---------- payload     Result pydantic input model  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Result
         * @param {BaseResult} baseResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResultApiV1ExamResultPost(baseResult: BaseResult, options?: any): AxiosPromise<ResultOut> {
            return localVarFp.createResultApiV1ExamResultPost(baseResult, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResultApiV1ExamResultResultIdDelete(resultId: ResultId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteResultApiV1ExamResultResultIdDelete(resultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing results of a certain task.  Parameters ---------- task_id     Id of parental task  Returns -------     List of task pydantic output model
         * @summary Get All Task Results
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId: TaskId, options?: any): AxiosPromise<Array<ResultOut>> {
            return localVarFp.getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get DICOM file of a result.  This endpoint in implemented in main without the result_router to omit the user authentification. The frontend uses cornerstone to load the image, which would need to know, how to authenticate with the backend. This is not to be done. TODO fix it!  Parameters ---------- result_id     UUID of the result with the dicom.  Returns -------     DICOM file response  Raises ------ HTTPException     Throws exception if result ID is unknown HTTPException     Throws exception if DICOM file does not exist
         * @summary Get Dicom
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDicomApiV1ExamDicomResultIdGet(resultId: ResultId, options?: any): AxiosPromise<void> {
            return localVarFp.getDicomApiV1ExamDicomResultIdGet(resultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing result.  Parameters ---------- result_id     Id of the result to be returned  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResultApiV1ExamResultResultIdGet(resultId: ResultId, options?: any): AxiosPromise<ResultOut> {
            return localVarFp.getResultApiV1ExamResultResultIdGet(resultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing result.  Parameters ---------- result_id     Id of the result to be updated payload     Result pydantic base model/dict     If this is the pydantic ResultBase model, only fields in the base model can be updated.  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Result
         * @param {ResultId} resultId 
         * @param {BaseResult} baseResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResultApiV1ExamResultResultIdPut(resultId: ResultId, baseResult: BaseResult, options?: any): AxiosPromise<ResultOut> {
            return localVarFp.updateResultApiV1ExamResultResultIdPut(resultId, baseResult, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a DICOM file to a result.  Parameters ---------- result_id     UUID of the result file     Dicom file user     User for authentification  Raises ------ HTTPException     Throws error if ID of the result is unknown
         * @summary Upload Dicom
         * @param {ResultId} resultId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDicomApiV1ExamDicomResultIdPost(resultId: ResultId, file: File, options?: any): AxiosPromise<any> {
            return localVarFp.uploadDicomApiV1ExamDicomResultIdPost(resultId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResultsApi - object-oriented interface
 * @export
 * @class ResultsApi
 * @extends {BaseAPI}
 */
export class ResultsApi extends BaseAPI {
    /**
     * Create a task result.  Parameters ---------- payload     Result pydantic input model  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Result
     * @param {BaseResult} baseResult 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public createResultApiV1ExamResultPost(baseResult: BaseResult, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).createResultApiV1ExamResultPost(baseResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Delete Result
     * @param {ResultId} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public deleteResultApiV1ExamResultResultIdDelete(resultId: ResultId, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).deleteResultApiV1ExamResultResultIdDelete(resultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing results of a certain task.  Parameters ---------- task_id     Id of parental task  Returns -------     List of task pydantic output model
     * @summary Get All Task Results
     * @param {TaskId} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get DICOM file of a result.  This endpoint in implemented in main without the result_router to omit the user authentification. The frontend uses cornerstone to load the image, which would need to know, how to authenticate with the backend. This is not to be done. TODO fix it!  Parameters ---------- result_id     UUID of the result with the dicom.  Returns -------     DICOM file response  Raises ------ HTTPException     Throws exception if result ID is unknown HTTPException     Throws exception if DICOM file does not exist
     * @summary Get Dicom
     * @param {ResultId} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public getDicomApiV1ExamDicomResultIdGet(resultId: ResultId, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getDicomApiV1ExamDicomResultIdGet(resultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing result.  Parameters ---------- result_id     Id of the result to be returned  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Get Result
     * @param {ResultId} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public getResultApiV1ExamResultResultIdGet(resultId: ResultId, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getResultApiV1ExamResultResultIdGet(resultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing result.  Parameters ---------- result_id     Id of the result to be updated payload     Result pydantic base model/dict     If this is the pydantic ResultBase model, only fields in the base model can be updated.  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Result
     * @param {ResultId} resultId 
     * @param {BaseResult} baseResult 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public updateResultApiV1ExamResultResultIdPut(resultId: ResultId, baseResult: BaseResult, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).updateResultApiV1ExamResultResultIdPut(resultId, baseResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a DICOM file to a result.  Parameters ---------- result_id     UUID of the result file     Dicom file user     User for authentification  Raises ------ HTTPException     Throws error if ID of the result is unknown
     * @summary Upload Dicom
     * @param {ResultId} resultId 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public uploadDicomApiV1ExamDicomResultIdPost(resultId: ResultId, file: File, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).uploadDicomApiV1ExamDicomResultIdPost(resultId, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskApiV1ExamTaskNewPost: async (payload: Payload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createTaskApiV1ExamTaskNewPost', 'payload', payload)
            const localVarPath = `/api/v1/exam/task/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task From Template
         * @param {string} workflowId 
         * @param {string} templateId 
         * @param {boolean} newTaskIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskFromTemplateApiV1ExamTaskPost: async (workflowId: string, templateId: string, newTaskIsTemplate: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('createTaskFromTemplateApiV1ExamTaskPost', 'workflowId', workflowId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('createTaskFromTemplateApiV1ExamTaskPost', 'templateId', templateId)
            // verify required parameter 'newTaskIsTemplate' is not null or undefined
            assertParamExists('createTaskFromTemplateApiV1ExamTaskPost', 'newTaskIsTemplate', newTaskIsTemplate)
            const localVarPath = `/api/v1/exam/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (workflowId !== undefined) {
                localVarQueryParameter['workflow_id'] = workflowId;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }

            if (newTaskIsTemplate !== undefined) {
                localVarQueryParameter['new_task_is_template'] = newTaskIsTemplate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskApiV1ExamTaskTaskIdDelete: async (taskId: TaskId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('deleteTaskApiV1ExamTaskTaskIdDelete', 'taskId', taskId)
            const localVarPath = `/api/v1/exam/task/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing task templates.  Returns -------     List of task pydantic output model
         * @summary Get All Task Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/task/templates/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
         * @summary Get All Workflow Tasks
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet: async (workflowId: WorkflowId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/exam/task/all/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskApiV1ExamTaskTaskIdGet: async (taskId: TaskId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTaskApiV1ExamTaskTaskIdGet', 'taskId', taskId)
            const localVarPath = `/api/v1/exam/task/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Task
         * @param {TaskId} taskId 
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskApiV1ExamTaskTaskIdPut: async (taskId: TaskId, payload: Payload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('updateTaskApiV1ExamTaskTaskIdPut', 'taskId', taskId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateTaskApiV1ExamTaskTaskIdPut', 'payload', payload)
            const localVarPath = `/api/v1/exam/task/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskApiV1ExamTaskNewPost(payload: Payload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateTaskApiV1ExamTaskNewPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskApiV1ExamTaskNewPost(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.createTaskApiV1ExamTaskNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task From Template
         * @param {string} workflowId 
         * @param {string} templateId 
         * @param {boolean} newTaskIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskFromTemplateApiV1ExamTaskPost(workflowId: string, templateId: string, newTaskIsTemplate: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateTaskFromTemplateApiV1ExamTaskPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskFromTemplateApiV1ExamTaskPost(workflowId, templateId, newTaskIsTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.createTaskFromTemplateApiV1ExamTaskPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskApiV1ExamTaskTaskIdDelete(taskId: TaskId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskApiV1ExamTaskTaskIdDelete(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.deleteTaskApiV1ExamTaskTaskIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing task templates.  Returns -------     List of task pydantic output model
         * @summary Get All Task Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
         * @summary Get All Workflow Tasks
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskApiV1ExamTaskTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetTaskApiV1ExamTaskTaskIdGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskApiV1ExamTaskTaskIdGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getTaskApiV1ExamTaskTaskIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Task
         * @param {TaskId} taskId 
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaskApiV1ExamTaskTaskIdPut(taskId: TaskId, payload: Payload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUpdateTaskApiV1ExamTaskTaskIdPut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaskApiV1ExamTaskTaskIdPut(taskId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.updateTaskApiV1ExamTaskTaskIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskApiV1ExamTaskNewPost(payload: Payload, options?: any): AxiosPromise<ResponseCreateTaskApiV1ExamTaskNewPost> {
            return localVarFp.createTaskApiV1ExamTaskNewPost(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task From Template
         * @param {string} workflowId 
         * @param {string} templateId 
         * @param {boolean} newTaskIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskFromTemplateApiV1ExamTaskPost(workflowId: string, templateId: string, newTaskIsTemplate: boolean, options?: any): AxiosPromise<ResponseCreateTaskFromTemplateApiV1ExamTaskPost> {
            return localVarFp.createTaskFromTemplateApiV1ExamTaskPost(workflowId, templateId, newTaskIsTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskApiV1ExamTaskTaskIdDelete(taskId: TaskId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTaskApiV1ExamTaskTaskIdDelete(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing task templates.  Returns -------     List of task pydantic output model
         * @summary Get All Task Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options?: any): AxiosPromise<Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>> {
            return localVarFp.getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
         * @summary Get All Workflow Tasks
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId: WorkflowId, options?: any): AxiosPromise<Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>> {
            return localVarFp.getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskApiV1ExamTaskTaskIdGet(taskId: TaskId, options?: any): AxiosPromise<ResponseGetTaskApiV1ExamTaskTaskIdGet> {
            return localVarFp.getTaskApiV1ExamTaskTaskIdGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Task
         * @param {TaskId} taskId 
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskApiV1ExamTaskTaskIdPut(taskId: TaskId, payload: Payload, options?: any): AxiosPromise<ResponseUpdateTaskApiV1ExamTaskTaskIdPut> {
            return localVarFp.updateTaskApiV1ExamTaskTaskIdPut(taskId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Task
     * @param {Payload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public createTaskApiV1ExamTaskNewPost(payload: Payload, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).createTaskApiV1ExamTaskNewPost(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Task From Template
     * @param {string} workflowId 
     * @param {string} templateId 
     * @param {boolean} newTaskIsTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public createTaskFromTemplateApiV1ExamTaskPost(workflowId: string, templateId: string, newTaskIsTemplate: boolean, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).createTaskFromTemplateApiV1ExamTaskPost(workflowId, templateId, newTaskIsTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Delete Task
     * @param {TaskId} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTaskApiV1ExamTaskTaskIdDelete(taskId: TaskId, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).deleteTaskApiV1ExamTaskTaskIdDelete(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing task templates.  Returns -------     List of task pydantic output model
     * @summary Get All Task Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
     * @summary Get All Workflow Tasks
     * @param {WorkflowId} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Get Task
     * @param {TaskId} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTaskApiV1ExamTaskTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTaskApiV1ExamTaskTaskIdGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Task
     * @param {TaskId} taskId 
     * @param {Payload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public updateTaskApiV1ExamTaskTaskIdPut(taskId: TaskId, payload: Payload, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).updateTaskApiV1ExamTaskTaskIdPut(taskId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowApiV1ExamWorkflowNewPost: async (baseWorkflow: BaseWorkflow, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseWorkflow' is not null or undefined
            assertParamExists('createWorkflowApiV1ExamWorkflowNewPost', 'baseWorkflow', baseWorkflow)
            const localVarPath = `/api/v1/exam/workflow/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseWorkflow, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow From Template
         * @param {string} examId 
         * @param {string} templateId 
         * @param {boolean} newWorkflowIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowFromTemplateApiV1ExamWorkflowPost: async (examId: string, templateId: string, newWorkflowIsTemplate: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('createWorkflowFromTemplateApiV1ExamWorkflowPost', 'examId', examId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('createWorkflowFromTemplateApiV1ExamWorkflowPost', 'templateId', templateId)
            // verify required parameter 'newWorkflowIsTemplate' is not null or undefined
            assertParamExists('createWorkflowFromTemplateApiV1ExamWorkflowPost', 'newWorkflowIsTemplate', newWorkflowIsTemplate)
            const localVarPath = `/api/v1/exam/workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (examId !== undefined) {
                localVarQueryParameter['exam_id'] = examId;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }

            if (newWorkflowIsTemplate !== undefined) {
                localVarQueryParameter['new_workflow_is_template'] = newWorkflowIsTemplate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete: async (workflowId: WorkflowId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete', 'workflowId', workflowId)
            const localVarPath = `/api/v1/exam/workflow/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
         * @summary Get All Exam Workflows
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet: async (examId: ExamId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet', 'examId', examId)
            const localVarPath = `/api/v1/exam/workflow/all/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all workflow templates.  Returns -------     List of workflow pydantic output model
         * @summary Get All Workflow Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/workflow/templates/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowApiV1ExamWorkflowWorkflowIdGet: async (workflowId: WorkflowId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowApiV1ExamWorkflowWorkflowIdGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/exam/workflow/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Workflow
         * @param {WorkflowId} workflowId 
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowApiV1ExamWorkflowWorkflowIdPut: async (workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('updateWorkflowApiV1ExamWorkflowWorkflowIdPut', 'workflowId', workflowId)
            // verify required parameter 'baseWorkflow' is not null or undefined
            assertParamExists('updateWorkflowApiV1ExamWorkflowWorkflowIdPut', 'baseWorkflow', baseWorkflow)
            const localVarPath = `/api/v1/exam/workflow/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseWorkflow, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflowApiV1ExamWorkflowNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow From Template
         * @param {string} examId 
         * @param {string} templateId 
         * @param {boolean} newWorkflowIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowFromTemplateApiV1ExamWorkflowPost(examId: string, templateId: string, newWorkflowIsTemplate: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowFromTemplateApiV1ExamWorkflowPost(examId, templateId, newWorkflowIsTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflowFromTemplateApiV1ExamWorkflowPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId: WorkflowId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
         * @summary Get All Exam Workflows
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all workflow templates.  Returns -------     List of workflow pydantic output model
         * @summary Get All Workflow Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getWorkflowApiV1ExamWorkflowWorkflowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Workflow
         * @param {WorkflowId} workflowId 
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId, baseWorkflow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.updateWorkflowApiV1ExamWorkflowWorkflowIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow: BaseWorkflow, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow From Template
         * @param {string} examId 
         * @param {string} templateId 
         * @param {boolean} newWorkflowIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowFromTemplateApiV1ExamWorkflowPost(examId: string, templateId: string, newWorkflowIsTemplate: boolean, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.createWorkflowFromTemplateApiV1ExamWorkflowPost(examId, templateId, newWorkflowIsTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId: WorkflowId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
         * @summary Get All Exam Workflows
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId: ExamId, options?: any): AxiosPromise<Array<WorkflowOut>> {
            return localVarFp.getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all workflow templates.  Returns -------     List of workflow pydantic output model
         * @summary Get All Workflow Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options?: any): AxiosPromise<Array<WorkflowOut>> {
            return localVarFp.getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId: WorkflowId, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Workflow
         * @param {WorkflowId} workflowId 
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId, baseWorkflow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Workflow
     * @param {BaseWorkflow} baseWorkflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Workflow From Template
     * @param {string} examId 
     * @param {string} templateId 
     * @param {boolean} newWorkflowIsTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowFromTemplateApiV1ExamWorkflowPost(examId: string, templateId: string, newWorkflowIsTemplate: boolean, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflowFromTemplateApiV1ExamWorkflowPost(examId, templateId, newWorkflowIsTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Delete Workflow
     * @param {WorkflowId} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId: WorkflowId, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
     * @summary Get All Exam Workflows
     * @param {ExamId} examId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all workflow templates.  Returns -------     List of workflow pydantic output model
     * @summary Get All Workflow Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Get Workflow
     * @param {WorkflowId} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Workflow
     * @param {WorkflowId} workflowId 
     * @param {BaseWorkflow} baseWorkflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId, baseWorkflow, options).then((request) => request(this.axios, this.basePath));
    }
}



