/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Pydantic definition of AcquisitionLimits.
 * @export
 * @interface AcquisitionLimits
 */
export interface AcquisitionLimits {
    /**
     * 
     * @type {number}
     * @memberof AcquisitionLimits
     */
    'patient_height': number;
    /**
     * 
     * @type {number}
     * @memberof AcquisitionLimits
     */
    'patient_weight': number;
    /**
     * 
     * @type {Gender}
     * @memberof AcquisitionLimits
     */
    'patient_gender'?: Gender;
    /**
     * 
     * @type {number}
     * @memberof AcquisitionLimits
     */
    'patient_age': number;
}


/**
 * Pydantic definition of acquisition parameters.
 * @export
 * @interface AcquisitionParameter
 */
export interface AcquisitionParameter {
    /**
     * 
     * @type {XYZ}
     * @memberof AcquisitionParameter
     */
    'fov_scaling': XYZ;
    /**
     * 
     * @type {XYZ}
     * @memberof AcquisitionParameter
     */
    'fov_offset': XYZ;
    /**
     * 
     * @type {XYZ}
     * @memberof AcquisitionParameter
     */
    'fov_rotation': XYZ;
}
/**
 * Acquisition Task output model.
 * @export
 * @interface AcquisitionTaskOut
 */
export interface AcquisitionTaskOut {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof AcquisitionTaskOut
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'description': string;
    /**
     * 
     * @type {TaskType}
     * @memberof AcquisitionTaskOut
     */
    'task_type': TaskType;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'destination': string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof AcquisitionTaskOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof AcquisitionTaskOut
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof AcquisitionTaskOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {DeviceId}
     * @memberof AcquisitionTaskOut
     */
    'device_id'?: DeviceId;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'sequence_id': string;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof AcquisitionTaskOut
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof AcquisitionTaskOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof AcquisitionTaskOut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {Array<ResultOut>}
     * @memberof AcquisitionTaskOut
     */
    'results': Array<ResultOut>;
    /**
     * 
     * @type {AcquisitionTaskOutAcquisitionLimits}
     * @memberof AcquisitionTaskOut
     */
    'acquisition_limits'?: AcquisitionTaskOutAcquisitionLimits;
}


/**
 * 
 * @export
 * @interface AcquisitionTaskOutAcquisitionLimits
 */
export interface AcquisitionTaskOutAcquisitionLimits {
    /**
     * 
     * @type {any}
     * @memberof AcquisitionTaskOutAcquisitionLimits
     */
    'patient_height': any;
    /**
     * 
     * @type {any}
     * @memberof AcquisitionTaskOutAcquisitionLimits
     */
    'patient_weight': any;
    /**
     * 
     * @type {Gender}
     * @memberof AcquisitionTaskOutAcquisitionLimits
     */
    'patient_gender'?: Gender;
    /**
     * 
     * @type {any}
     * @memberof AcquisitionTaskOutAcquisitionLimits
     */
    'patient_age': any;
}


/**
 * Represents a task for data acquisition in the system.
 * @export
 * @interface BaseAcquisitionTask
 */
export interface BaseAcquisitionTask {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof BaseAcquisitionTask
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'task_type': string;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'destination': string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseAcquisitionTask
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof BaseAcquisitionTask
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAcquisitionTask
     */
    'is_template': boolean;
    /**
     * 
     * @type {DeviceId}
     * @memberof BaseAcquisitionTask
     */
    'device_id'?: DeviceId;
    /**
     * 
     * @type {string}
     * @memberof BaseAcquisitionTask
     */
    'sequence_id': string;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof BaseAcquisitionTask
     */
    'acquisition_parameter': AcquisitionParameter;
}


/**
 * Workflow task model.
 * @export
 * @interface BaseDAGTask
 */
export interface BaseDAGTask {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof BaseDAGTask
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'task_type': string;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'destination': string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseDAGTask
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof BaseDAGTask
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseDAGTask
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'dag_type': BaseDAGTaskDagTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BaseDAGTask
     */
    'dag_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseDAGTask
     */
    'input_task_ids'?: Array<string>;
    /**
     * 
     * @type {Parameter}
     * @memberof BaseDAGTask
     */
    'parameter'?: Parameter;
}

export const BaseDAGTaskDagTypeEnum = {
    Reconstruction: 'RECONSTRUCTION',
    Processing: 'PROCESSING'
} as const;

export type BaseDAGTaskDagTypeEnum = typeof BaseDAGTaskDagTypeEnum[keyof typeof BaseDAGTaskDagTypeEnum];

/**
 * Exam base model.
 * @export
 * @interface BaseExam
 */
export interface BaseExam {
    /**
     * 
     * @type {PatientId}
     * @memberof BaseExam
     */
    'patient_id'?: PatientId;
    /**
     * 
     * @type {string}
     * @memberof BaseExam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseExam
     */
    'description': string;
    /**
     * 
     * @type {Indication}
     * @memberof BaseExam
     */
    'indication'?: Indication;
    /**
     * 
     * @type {Comment}
     * @memberof BaseExam
     */
    'comment'?: Comment;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseExam
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof BaseExam
     */
    'is_template': boolean;
}


/**
 * Base model for MRI sequence.
 * @export
 * @interface BaseMRISequence
 */
export interface BaseMRISequence {
    /**
     * 
     * @type {string}
     * @memberof BaseMRISequence
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseMRISequence
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BaseMRISequence
     */
    'sequence_type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseMRISequence
     */
    'tags'?: Array<string>;
}
/**
 * Workflow base model.
 * @export
 * @interface BaseWorkflow
 */
export interface BaseWorkflow {
    /**
     * 
     * @type {ExamId1}
     * @memberof BaseWorkflow
     */
    'exam_id'?: ExamId1;
    /**
     * 
     * @type {string}
     * @memberof BaseWorkflow
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseWorkflow
     */
    'description': string;
    /**
     * 
     * @type {Comment}
     * @memberof BaseWorkflow
     */
    'comment'?: Comment;
    /**
     * 
     * @type {ItemStatus}
     * @memberof BaseWorkflow
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof BaseWorkflow
     */
    'is_template': boolean;
}


/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
}
/**
 * Workflow Task output model.
 * @export
 * @interface DAGTaskOut
 */
export interface DAGTaskOut {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof DAGTaskOut
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'description': string;
    /**
     * 
     * @type {TaskType}
     * @memberof DAGTaskOut
     */
    'task_type': TaskType;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'destination': string;
    /**
     * 
     * @type {ItemStatus}
     * @memberof DAGTaskOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {number}
     * @memberof DAGTaskOut
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof DAGTaskOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'dag_type': DAGTaskOutDagTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'dag_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DAGTaskOut
     */
    'input_task_ids'?: Array<string>;
    /**
     * 
     * @type {Parameter}
     * @memberof DAGTaskOut
     */
    'parameter'?: Parameter;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof DAGTaskOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof DAGTaskOut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {Array<ResultOut>}
     * @memberof DAGTaskOut
     */
    'results': Array<ResultOut>;
}

export const DAGTaskOutDagTypeEnum = {
    Reconstruction: 'RECONSTRUCTION',
    Processing: 'PROCESSING'
} as const;

export type DAGTaskOutDagTypeEnum = typeof DAGTaskOutDagTypeEnum[keyof typeof DAGTaskOutDagTypeEnum];

/**
 * 
 * @export
 * @interface DatetimeUpdated
 */
export interface DatetimeUpdated {
}
/**
 * 
 * @export
 * @interface DeviceId
 */
export interface DeviceId {
}
/**
 * 
 * @export
 * @interface ExamId
 */
export interface ExamId {
}
/**
 * 
 * @export
 * @interface ExamId1
 */
export interface ExamId1 {
}
/**
 * Exam output model.
 * @export
 * @interface ExamOut
 */
export interface ExamOut {
    /**
     * 
     * @type {PatientId}
     * @memberof ExamOut
     */
    'patient_id'?: PatientId;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'description': string;
    /**
     * 
     * @type {Indication}
     * @memberof ExamOut
     */
    'indication'?: Indication;
    /**
     * 
     * @type {Comment}
     * @memberof ExamOut
     */
    'comment'?: Comment;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ExamOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof ExamOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof ExamOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ExamOut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {Array<WorkflowOut>}
     * @memberof ExamOut
     */
    'workflows': Array<WorkflowOut>;
}


/**
 * 
 * @export
 * @interface FileExtension
 */
export interface FileExtension {
}
/**
 * Pydantic definition of genders.
 * @export
 * @enum {string}
 */

export const Gender = {
    Male: 'MALE',
    Female: 'FEMALE',
    Other: 'OTHER',
    NotGiven: 'NOT_GIVEN'
} as const;

export type Gender = typeof Gender[keyof typeof Gender];


/**
 * 
 * @export
 * @interface GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
 */
export interface GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'is_template': any;
    /**
     * 
     * @type {DeviceId}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'device_id'?: DeviceId;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'results': any;
    /**
     * 
     * @type {AcquisitionTaskOutAcquisitionLimits}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'acquisition_limits'?: AcquisitionTaskOutAcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'dag_type': GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInnerDagTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'dag_id': any;
    /**
     * 
     * @type {any}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'input_task_ids'?: any;
    /**
     * 
     * @type {Parameter}
     * @memberof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner
     */
    'parameter'?: Parameter;
}

export const GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInnerDagTypeEnum = {
    Reconstruction: 'RECONSTRUCTION',
    Processing: 'PROCESSING'
} as const;

export type GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInnerDagTypeEnum = typeof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInnerDagTypeEnum[keyof typeof GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInnerDagTypeEnum];

/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Indication
 */
export interface Indication {
}
/**
 * Task status enum.
 * @export
 * @enum {string}
 */

export const ItemStatus = {
    New: 'NEW',
    Updated: 'UPDATED',
    Started: 'STARTED',
    Finished: 'FINISHED',
    Error: 'ERROR',
    Inprogress: 'INPROGRESS'
} as const;

export type ItemStatus = typeof ItemStatus[keyof typeof ItemStatus];


/**
 * ISMRM raw data / (ISMR)MRD acquisition info.
 * @export
 * @interface MRDAcquisitionInfo
 */
export interface MRDAcquisitionInfo {
    /**
     * 
     * @type {number}
     * @memberof MRDAcquisitionInfo
     */
    'acquisition_id': number;
    /**
     * 
     * @type {number}
     * @memberof MRDAcquisitionInfo
     */
    'num_samples': number;
    /**
     * 
     * @type {number}
     * @memberof MRDAcquisitionInfo
     */
    'num_coils': number;
    /**
     * 
     * @type {number}
     * @memberof MRDAcquisitionInfo
     */
    'dwell_time': number;
}
/**
 * ISMRM raw data / (ISMR)MRD meta data response.
 * @export
 * @interface MRDMetaResponse
 */
export interface MRDMetaResponse {
    /**
     * 
     * @type {string}
     * @memberof MRDMetaResponse
     */
    'workflow_id': string;
    /**
     * 
     * @type {string}
     * @memberof MRDMetaResponse
     */
    'task_id': string;
    /**
     * 
     * @type {string}
     * @memberof MRDMetaResponse
     */
    'result_id': string;
    /**
     * 
     * @type {string}
     * @memberof MRDMetaResponse
     */
    'dtype'?: string;
    /**
     * 
     * @type {Array<MRDAcquisitionInfo>}
     * @memberof MRDMetaResponse
     */
    'acquisitions'?: Array<MRDAcquisitionInfo>;
}
/**
 * Output model for MRI sequence.
 * @export
 * @interface MRISequenceOut
 */
export interface MRISequenceOut {
    /**
     * 
     * @type {string}
     * @memberof MRISequenceOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MRISequenceOut
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof MRISequenceOut
     */
    'sequence_type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MRISequenceOut
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MRISequenceOut
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof MRISequenceOut
     */
    'created_at': string;
    /**
     * 
     * @type {UpdatedAt}
     * @memberof MRISequenceOut
     */
    'updated_at'?: UpdatedAt;
    /**
     * 
     * @type {any}
     * @memberof MRISequenceOut
     */
    'file': any;
    /**
     * 
     * @type {FileExtension}
     * @memberof MRISequenceOut
     */
    'file_extension'?: FileExtension;
}
/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
}
/**
 * 
 * @export
 * @interface Parameter
 */
export interface Parameter {
}
/**
 * 
 * @export
 * @interface PatientId
 */
export interface PatientId {
}
/**
 * @type Payload
 * @export
 */
export type Payload = { task_type: 'ACQUISITION' } & BaseAcquisitionTask | { task_type: 'DAG' } & BaseDAGTask;

/**
 * 
 * @export
 * @interface ResponseCreateTaskApiV1ExamTaskNewPost
 */
export interface ResponseCreateTaskApiV1ExamTaskNewPost {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'is_template': any;
    /**
     * 
     * @type {DeviceId}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'device_id'?: DeviceId;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'results': any;
    /**
     * 
     * @type {AcquisitionTaskOutAcquisitionLimits}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'acquisition_limits'?: AcquisitionTaskOutAcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'dag_type': ResponseCreateTaskApiV1ExamTaskNewPostDagTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'dag_id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'input_task_ids'?: any;
    /**
     * 
     * @type {Parameter}
     * @memberof ResponseCreateTaskApiV1ExamTaskNewPost
     */
    'parameter'?: Parameter;
}

export const ResponseCreateTaskApiV1ExamTaskNewPostDagTypeEnum = {
    Reconstruction: 'RECONSTRUCTION',
    Processing: 'PROCESSING'
} as const;

export type ResponseCreateTaskApiV1ExamTaskNewPostDagTypeEnum = typeof ResponseCreateTaskApiV1ExamTaskNewPostDagTypeEnum[keyof typeof ResponseCreateTaskApiV1ExamTaskNewPostDagTypeEnum];

/**
 * 
 * @export
 * @interface ResponseCreateTaskFromTemplateApiV1ExamTaskPost
 */
export interface ResponseCreateTaskFromTemplateApiV1ExamTaskPost {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'is_template': any;
    /**
     * 
     * @type {DeviceId}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'device_id'?: DeviceId;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'results': any;
    /**
     * 
     * @type {AcquisitionTaskOutAcquisitionLimits}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'acquisition_limits'?: AcquisitionTaskOutAcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'dag_type': ResponseCreateTaskFromTemplateApiV1ExamTaskPostDagTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'dag_id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'input_task_ids'?: any;
    /**
     * 
     * @type {Parameter}
     * @memberof ResponseCreateTaskFromTemplateApiV1ExamTaskPost
     */
    'parameter'?: Parameter;
}

export const ResponseCreateTaskFromTemplateApiV1ExamTaskPostDagTypeEnum = {
    Reconstruction: 'RECONSTRUCTION',
    Processing: 'PROCESSING'
} as const;

export type ResponseCreateTaskFromTemplateApiV1ExamTaskPostDagTypeEnum = typeof ResponseCreateTaskFromTemplateApiV1ExamTaskPostDagTypeEnum[keyof typeof ResponseCreateTaskFromTemplateApiV1ExamTaskPostDagTypeEnum];

/**
 * 
 * @export
 * @interface ResponseGetTaskApiV1ExamTaskTaskIdGet
 */
export interface ResponseGetTaskApiV1ExamTaskTaskIdGet {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'is_template': any;
    /**
     * 
     * @type {DeviceId}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'device_id'?: DeviceId;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'results': any;
    /**
     * 
     * @type {AcquisitionTaskOutAcquisitionLimits}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'acquisition_limits'?: AcquisitionTaskOutAcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'dag_type': ResponseGetTaskApiV1ExamTaskTaskIdGetDagTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'dag_id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'input_task_ids'?: any;
    /**
     * 
     * @type {Parameter}
     * @memberof ResponseGetTaskApiV1ExamTaskTaskIdGet
     */
    'parameter'?: Parameter;
}

export const ResponseGetTaskApiV1ExamTaskTaskIdGetDagTypeEnum = {
    Reconstruction: 'RECONSTRUCTION',
    Processing: 'PROCESSING'
} as const;

export type ResponseGetTaskApiV1ExamTaskTaskIdGetDagTypeEnum = typeof ResponseGetTaskApiV1ExamTaskTaskIdGetDagTypeEnum[keyof typeof ResponseGetTaskApiV1ExamTaskTaskIdGetDagTypeEnum];

/**
 * 
 * @export
 * @interface ResponseUpdateTaskApiV1ExamTaskTaskIdPut
 */
export interface ResponseUpdateTaskApiV1ExamTaskTaskIdPut {
    /**
     * 
     * @type {WorkflowId1}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'workflow_id'?: WorkflowId1;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'description': any;
    /**
     * 
     * @type {TaskType}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'task_type': TaskType;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'destination': any;
    /**
     * 
     * @type {ItemStatus}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'progress': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'is_template': any;
    /**
     * 
     * @type {DeviceId}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'device_id'?: DeviceId;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'sequence_id': any;
    /**
     * 
     * @type {AcquisitionParameter}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'acquisition_parameter': AcquisitionParameter;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'creator': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'datetime_created': any;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'results': any;
    /**
     * 
     * @type {AcquisitionTaskOutAcquisitionLimits}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'acquisition_limits'?: AcquisitionTaskOutAcquisitionLimits;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'dag_type': ResponseUpdateTaskApiV1ExamTaskTaskIdPutDagTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'dag_id': any;
    /**
     * 
     * @type {any}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'input_task_ids'?: any;
    /**
     * 
     * @type {Parameter}
     * @memberof ResponseUpdateTaskApiV1ExamTaskTaskIdPut
     */
    'parameter'?: Parameter;
}

export const ResponseUpdateTaskApiV1ExamTaskTaskIdPutDagTypeEnum = {
    Reconstruction: 'RECONSTRUCTION',
    Processing: 'PROCESSING'
} as const;

export type ResponseUpdateTaskApiV1ExamTaskTaskIdPutDagTypeEnum = typeof ResponseUpdateTaskApiV1ExamTaskTaskIdPutDagTypeEnum[keyof typeof ResponseUpdateTaskApiV1ExamTaskTaskIdPutDagTypeEnum];

/**
 * 
 * @export
 * @interface ResultId
 */
export interface ResultId {
}
/**
 * Result output model.
 * @export
 * @interface ResultOut
 */
export interface ResultOut {
    /**
     * 
     * @type {ResultType}
     * @memberof ResultOut
     */
    'type': ResultType;
    /**
     * 
     * @type {string}
     * @memberof ResultOut
     */
    'directory': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResultOut
     */
    'files'?: Array<string>;
    /**
     * 
     * @type {Meta}
     * @memberof ResultOut
     */
    'meta'?: Meta;
    /**
     * 
     * @type {string}
     * @memberof ResultOut
     */
    'task_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResultOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResultOut
     */
    'datetime_created': string;
}


/**
 * Result type enum.
 * @export
 * @enum {string}
 */

export const ResultType = {
    Dicom: 'DICOM',
    Mrd: 'MRD',
    Numpy: 'NUMPY',
    Calibration: 'CALIBRATION',
    NotSet: 'NOT_SET'
} as const;

export type ResultType = typeof ResultType[keyof typeof ResultType];


/**
 * Update result model.
 * @export
 * @interface SetResult
 */
export interface SetResult {
    /**
     * 
     * @type {ResultType}
     * @memberof SetResult
     */
    'type': ResultType;
    /**
     * 
     * @type {string}
     * @memberof SetResult
     */
    'directory': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SetResult
     */
    'files'?: Array<string>;
    /**
     * 
     * @type {Meta}
     * @memberof SetResult
     */
    'meta'?: Meta;
}


/**
 * 
 * @export
 * @interface TaskId
 */
export interface TaskId {
}
/**
 * 
 * @export
 * @interface TaskId1
 */
export interface TaskId1 {
}
/**
 * Task type enum.
 * @export
 * @enum {string}
 */

export const TaskType = {
    Acquisition: 'ACQUISITION',
    Dag: 'DAG',
    Reconstruction: 'RECONSTRUCTION',
    Processing: 'PROCESSING'
} as const;

export type TaskType = typeof TaskType[keyof typeof TaskType];


/**
 * 
 * @export
 * @interface UpdatedAt
 */
export interface UpdatedAt {
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * 
 * @export
 * @interface WorkflowId
 */
export interface WorkflowId {
}
/**
 * 
 * @export
 * @interface WorkflowId1
 */
export interface WorkflowId1 {
}
/**
 * Workflow output model.
 * @export
 * @interface WorkflowOut
 */
export interface WorkflowOut {
    /**
     * 
     * @type {ExamId1}
     * @memberof WorkflowOut
     */
    'exam_id'?: ExamId1;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'description': string;
    /**
     * 
     * @type {Comment}
     * @memberof WorkflowOut
     */
    'comment'?: Comment;
    /**
     * 
     * @type {ItemStatus}
     * @memberof WorkflowOut
     */
    'status': ItemStatus;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowOut
     */
    'is_template': boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOut
     */
    'datetime_created': string;
    /**
     * 
     * @type {DatetimeUpdated}
     * @memberof WorkflowOut
     */
    'datetime_updated'?: DatetimeUpdated;
    /**
     * 
     * @type {Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>}
     * @memberof WorkflowOut
     */
    'tasks': Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>;
}


/**
 * Pydantic definition of coordinates.
 * @export
 * @interface XYZ
 */
export interface XYZ {
    /**
     * 
     * @type {number}
     * @memberof XYZ
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof XYZ
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof XYZ
     */
    'z': number;
}

/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Serve a DICOM instance.    - If it\'s already a DICOM Part-10 file → return FileResponse (supports HTTP Range).   - Else → convert to Part-10 in memory and return StreamingResponse.  Headers:   - \'application/dicom\' content type   - inline disposition (avoid forced download)   - \'Cache-Control: no-transform\' to prevent proxies from gzipping (which breaks Range offsets)
         * @summary Get DICOM result
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDicom: async (workflowId: string, taskId: string, resultId: string, filename: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getDicom', 'workflowId', workflowId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getDicom', 'taskId', taskId)
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getDicom', 'resultId', resultId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getDicom', 'filename', filename)
            const localVarPath = `/api/v1/exam/dcm/{workflow_id}/{task_id}/{result_id}/{filename}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MRD as binary stream.
         * @summary Get MRD (binary, interleaved float32 complex)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} ids IDs: \&#39;0,1,10-20,40-50:2\&#39;
         * @param {number} [coilIdx] Coil index
         * @param {number} [stride] Decimate samples by stride
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMRD: async (workflowId: string, taskId: string, resultId: string, ids: string, coilIdx?: number, stride?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getMRD', 'workflowId', workflowId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getMRD', 'taskId', taskId)
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getMRD', 'resultId', resultId)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getMRD', 'ids', ids)
            const localVarPath = `/api/v1/exam/mrd/{workflow_id}/{task_id}/{result_id}/data`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (coilIdx !== undefined) {
                localVarQueryParameter['coil_idx'] = coilIdx;
            }

            if (stride !== undefined) {
                localVarQueryParameter['stride'] = stride;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MRD meta info.
         * @summary Get ISMRMRD metadata (indexed acquisitions)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMrdMeta: async (workflowId: string, taskId: string, resultId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getMrdMeta', 'workflowId', workflowId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getMrdMeta', 'taskId', taskId)
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getMrdMeta', 'resultId', resultId)
            const localVarPath = `/api/v1/exam/mrd/{workflow_id}/{task_id}/{result_id}/meta`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * Serve a DICOM instance.    - If it\'s already a DICOM Part-10 file → return FileResponse (supports HTTP Range).   - Else → convert to Part-10 in memory and return StreamingResponse.  Headers:   - \'application/dicom\' content type   - inline disposition (avoid forced download)   - \'Cache-Control: no-transform\' to prevent proxies from gzipping (which breaks Range offsets)
         * @summary Get DICOM result
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDicom(workflowId: string, taskId: string, resultId: string, filename: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDicom(workflowId, taskId, resultId, filename, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.getDicom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get MRD as binary stream.
         * @summary Get MRD (binary, interleaved float32 complex)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} ids IDs: \&#39;0,1,10-20,40-50:2\&#39;
         * @param {number} [coilIdx] Coil index
         * @param {number} [stride] Decimate samples by stride
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMRD(workflowId: string, taskId: string, resultId: string, ids: string, coilIdx?: number, stride?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMRD(workflowId, taskId, resultId, ids, coilIdx, stride, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.getMRD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get MRD meta info.
         * @summary Get ISMRMRD metadata (indexed acquisitions)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMrdMeta(workflowId: string, taskId: string, resultId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MRDMetaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMrdMeta(workflowId, taskId, resultId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.getMrdMeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * Serve a DICOM instance.    - If it\'s already a DICOM Part-10 file → return FileResponse (supports HTTP Range).   - Else → convert to Part-10 in memory and return StreamingResponse.  Headers:   - \'application/dicom\' content type   - inline disposition (avoid forced download)   - \'Cache-Control: no-transform\' to prevent proxies from gzipping (which breaks Range offsets)
         * @summary Get DICOM result
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDicom(workflowId: string, taskId: string, resultId: string, filename: string, options?: any): AxiosPromise<any> {
            return localVarFp.getDicom(workflowId, taskId, resultId, filename, options).then((request) => request(axios, basePath));
        },
        /**
         * Get MRD as binary stream.
         * @summary Get MRD (binary, interleaved float32 complex)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} ids IDs: \&#39;0,1,10-20,40-50:2\&#39;
         * @param {number} [coilIdx] Coil index
         * @param {number} [stride] Decimate samples by stride
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMRD(workflowId: string, taskId: string, resultId: string, ids: string, coilIdx?: number, stride?: number, options?: any): AxiosPromise<any> {
            return localVarFp.getMRD(workflowId, taskId, resultId, ids, coilIdx, stride, options).then((request) => request(axios, basePath));
        },
        /**
         * Get MRD meta info.
         * @summary Get ISMRMRD metadata (indexed acquisitions)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMrdMeta(workflowId: string, taskId: string, resultId: string, options?: any): AxiosPromise<MRDMetaResponse> {
            return localVarFp.getMrdMeta(workflowId, taskId, resultId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Serve a DICOM instance.    - If it\'s already a DICOM Part-10 file → return FileResponse (supports HTTP Range).   - Else → convert to Part-10 in memory and return StreamingResponse.  Headers:   - \'application/dicom\' content type   - inline disposition (avoid forced download)   - \'Cache-Control: no-transform\' to prevent proxies from gzipping (which breaks Range offsets)
     * @summary Get DICOM result
     * @param {string} workflowId 
     * @param {string} taskId 
     * @param {string} resultId 
     * @param {string} filename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public getDicom(workflowId: string, taskId: string, resultId: string, filename: string, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).getDicom(workflowId, taskId, resultId, filename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get MRD as binary stream.
     * @summary Get MRD (binary, interleaved float32 complex)
     * @param {string} workflowId 
     * @param {string} taskId 
     * @param {string} resultId 
     * @param {string} ids IDs: \&#39;0,1,10-20,40-50:2\&#39;
     * @param {number} [coilIdx] Coil index
     * @param {number} [stride] Decimate samples by stride
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public getMRD(workflowId: string, taskId: string, resultId: string, ids: string, coilIdx?: number, stride?: number, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).getMRD(workflowId, taskId, resultId, ids, coilIdx, stride, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get MRD meta info.
     * @summary Get ISMRMRD metadata (indexed acquisitions)
     * @param {string} workflowId 
     * @param {string} taskId 
     * @param {string} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public getMrdMeta(workflowId: string, taskId: string, resultId: string, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).getMrdMeta(workflowId, taskId, resultId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExamsApi - axios parameter creator
 * @export
 */
export const ExamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamApiV1ExamNewPost: async (baseExam: BaseExam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseExam' is not null or undefined
            assertParamExists('createExamApiV1ExamNewPost', 'baseExam', baseExam)
            const localVarPath = `/api/v1/exam/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseExam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam From Template
         * @param {string} templateId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamFromTemplateApiV1ExamPost: async (templateId: string, baseExam: BaseExam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('createExamFromTemplateApiV1ExamPost', 'templateId', templateId)
            // verify required parameter 'baseExam' is not null or undefined
            assertParamExists('createExamFromTemplateApiV1ExamPost', 'baseExam', baseExam)
            const localVarPath = `/api/v1/exam/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseExam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Exam Delete
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examDeleteApiV1ExamExamIdDelete: async (examId: ExamId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('examDeleteApiV1ExamExamIdDelete', 'examId', examId)
            const localVarPath = `/api/v1/exam/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all exam templates.  Returns -------     List of exam pydantic output models
         * @summary Get All Exam Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamTemplatesApiV1ExamTemplatesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/templates/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
         * @summary Get All Patient Exams
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPatientExamsApiV1ExamAllPatientIdGet: async (patientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('getAllPatientExamsApiV1ExamAllPatientIdGet', 'patientId', patientId)
            const localVarPath = `/api/v1/exam/all/{patient_id}`
                .replace(`{${"patient_id"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
         * @summary Get Exam
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamApiV1ExamExamIdGet: async (examId: ExamId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('getExamApiV1ExamExamIdGet', 'examId', examId)
            const localVarPath = `/api/v1/exam/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Exam
         * @param {ExamId} examId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExamApiV1ExamExamIdPut: async (examId: ExamId, baseExam: BaseExam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('updateExamApiV1ExamExamIdPut', 'examId', examId)
            // verify required parameter 'baseExam' is not null or undefined
            assertParamExists('updateExamApiV1ExamExamIdPut', 'baseExam', baseExam)
            const localVarPath = `/api/v1/exam/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseExam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExamsApi - functional programming interface
 * @export
 */
export const ExamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExamApiV1ExamNewPost(baseExam: BaseExam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExamApiV1ExamNewPost(baseExam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.createExamApiV1ExamNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam From Template
         * @param {string} templateId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExamFromTemplateApiV1ExamPost(templateId: string, baseExam: BaseExam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExamFromTemplateApiV1ExamPost(templateId, baseExam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.createExamFromTemplateApiV1ExamPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Exam Delete
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examDeleteApiV1ExamExamIdDelete(examId: ExamId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examDeleteApiV1ExamExamIdDelete(examId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.examDeleteApiV1ExamExamIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all exam templates.  Returns -------     List of exam pydantic output models
         * @summary Get All Exam Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExamTemplatesApiV1ExamTemplatesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllExamTemplatesApiV1ExamTemplatesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.getAllExamTemplatesApiV1ExamTemplatesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
         * @summary Get All Patient Exams
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPatientExamsApiV1ExamAllPatientIdGet(patientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPatientExamsApiV1ExamAllPatientIdGet(patientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.getAllPatientExamsApiV1ExamAllPatientIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
         * @summary Get Exam
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExamApiV1ExamExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExamApiV1ExamExamIdGet(examId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.getExamApiV1ExamExamIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Exam
         * @param {ExamId} examId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExamApiV1ExamExamIdPut(examId: ExamId, baseExam: BaseExam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExamApiV1ExamExamIdPut(examId, baseExam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamsApi.updateExamApiV1ExamExamIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExamsApi - factory interface
 * @export
 */
export const ExamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExamsApiFp(configuration)
    return {
        /**
         * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamApiV1ExamNewPost(baseExam: BaseExam, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.createExamApiV1ExamNewPost(baseExam, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Exam From Template
         * @param {string} templateId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamFromTemplateApiV1ExamPost(templateId: string, baseExam: BaseExam, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.createExamFromTemplateApiV1ExamPost(templateId, baseExam, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Exam Delete
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examDeleteApiV1ExamExamIdDelete(examId: ExamId, options?: any): AxiosPromise<void> {
            return localVarFp.examDeleteApiV1ExamExamIdDelete(examId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all exam templates.  Returns -------     List of exam pydantic output models
         * @summary Get All Exam Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamTemplatesApiV1ExamTemplatesAllGet(options?: any): AxiosPromise<Array<ExamOut>> {
            return localVarFp.getAllExamTemplatesApiV1ExamTemplatesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
         * @summary Get All Patient Exams
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPatientExamsApiV1ExamAllPatientIdGet(patientId: string, options?: any): AxiosPromise<Array<ExamOut>> {
            return localVarFp.getAllPatientExamsApiV1ExamAllPatientIdGet(patientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
         * @summary Get Exam
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamApiV1ExamExamIdGet(examId: ExamId, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.getExamApiV1ExamExamIdGet(examId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Exam
         * @param {ExamId} examId 
         * @param {BaseExam} baseExam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExamApiV1ExamExamIdPut(examId: ExamId, baseExam: BaseExam, options?: any): AxiosPromise<ExamOut> {
            return localVarFp.updateExamApiV1ExamExamIdPut(examId, baseExam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExamsApi - object-oriented interface
 * @export
 * @class ExamsApi
 * @extends {BaseAPI}
 */
export class ExamsApi extends BaseAPI {
    /**
     * Create a new exam.  Parameters ---------- payload     Exam pydantic input model.  Returns -------     Exam pydantic output moddel.  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Exam
     * @param {BaseExam} baseExam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public createExamApiV1ExamNewPost(baseExam: BaseExam, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).createExamApiV1ExamNewPost(baseExam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new exam from template.  Parameters ---------- payload     The potentially modified exam to create. template_id     ID of the template, the exam is created from  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Exam From Template
     * @param {string} templateId 
     * @param {BaseExam} baseExam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public createExamFromTemplateApiV1ExamPost(templateId: string, baseExam: BaseExam, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).createExamFromTemplateApiV1ExamPost(templateId, baseExam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an exam by id. Cascade deletes the associated workflow and tasks.  Parameters ---------- exam_id     Id of the exam to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Exam Delete
     * @param {ExamId} examId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examDeleteApiV1ExamExamIdDelete(examId: ExamId, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examDeleteApiV1ExamExamIdDelete(examId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all exam templates.  Returns -------     List of exam pydantic output models
     * @summary Get All Exam Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public getAllExamTemplatesApiV1ExamTemplatesAllGet(options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).getAllExamTemplatesApiV1ExamTemplatesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all exams of a certain patient.  Parameters ---------- patient_id     Id of parent  Returns -------     List of exam pydantic output models
     * @summary Get All Patient Exams
     * @param {string} patientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public getAllPatientExamsApiV1ExamAllPatientIdGet(patientId: string, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).getAllPatientExamsApiV1ExamAllPatientIdGet(patientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get exam endpoint.  Parameters ---------- exam_id     Id of requested exam entry  Returns -------     Exam pydantic output model.  Raises ------ HTTPException     404: Not found
     * @summary Get Exam
     * @param {ExamId} examId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public getExamApiV1ExamExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).getExamApiV1ExamExamIdGet(examId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing exam.  Parameters ---------- exam_id     Id of the exam to be updated payload     Exam pydantic input model  Returns -------     Exam pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Exam
     * @param {ExamId} examId 
     * @param {BaseExam} baseExam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public updateExamApiV1ExamExamIdPut(examId: ExamId, baseExam: BaseExam, options?: RawAxiosRequestConfig) {
        return ExamsApiFp(this.configuration).updateExamApiV1ExamExamIdPut(examId, baseExam, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get status / health endpoint.
         * @summary Readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessApiV1ExamHealthReadinessGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/health/readiness`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get status / health endpoint.
         * @summary Readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readinessApiV1ExamHealthReadinessGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readinessApiV1ExamHealthReadinessGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.readinessApiV1ExamHealthReadinessGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Get status / health endpoint.
         * @summary Readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessApiV1ExamHealthReadinessGet(options?: any): AxiosPromise<any> {
            return localVarFp.readinessApiV1ExamHealthReadinessGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Get status / health endpoint.
     * @summary Readiness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public readinessApiV1ExamHealthReadinessGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).readinessApiV1ExamHealthReadinessGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MriSequencesApi - axios parameter creator
 * @export
 */
export const MriSequencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload an MRI sequence file and store it with the provided metadata.  Parameters ---------- mri_sequence : MRISequenceCreate     The MRI sequence metadata. file : UploadFile     The MRI sequence file to store. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The stored MRI sequence with the uploaded file.
         * @summary Create Mri Sequence
         * @param {File} file 
         * @param {string} name 
         * @param {string} [description] 
         * @param {string} [sequenceType] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMriSequenceApiV1ExamSequencePost: async (file: File, name: string, description?: string, sequenceType?: string, tags?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createMriSequenceApiV1ExamSequencePost', 'file', file)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createMriSequenceApiV1ExamSequencePost', 'name', name)
            const localVarPath = `/api/v1/exam/sequence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (sequenceType !== undefined) { 
                localVarFormParams.append('sequence_type', sequenceType as any);
            }
                if (tags) {
                localVarFormParams.append('tags', tags.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to delete. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- None
         * @summary Delete Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete: async (sequenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            assertParamExists('deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete', 'sequenceId', sequenceId)
            const localVarPath = `/api/v1/exam/sequence/{sequence_id}`
                .replace(`{${"sequence_id"}}`, encodeURIComponent(String(sequenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all MRI sequences from the database.  Parameters ---------- database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- List[MRISequence]     The list of MRI sequences.
         * @summary Get All Mri Sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMriSequencesApiV1ExamSequencesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/sequences/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The retrieved MRI sequence.
         * @summary Get Mri Sequence By Id
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMriSequenceByIdApiV1ExamSequenceSequenceIdGet: async (sequenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            assertParamExists('getMriSequenceByIdApiV1ExamSequenceSequenceIdGet', 'sequenceId', sequenceId)
            const localVarPath = `/api/v1/exam/sequence/{sequence_id}`
                .replace(`{${"sequence_id"}}`, encodeURIComponent(String(sequenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an MRI sequence file by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. background_tasks : BackgroundTasks     The background tasks to run. name : str     The name of the file to download. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- FileResponse     The retrieved MRI sequence file.
         * @summary Get Mri Sequence File By Id
         * @param {string} sequenceId 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet: async (sequenceId: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            assertParamExists('getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet', 'sequenceId', sequenceId)
            const localVarPath = `/api/v1/exam/sequence/{sequence_id}/file`
                .replace(`{${"sequence_id"}}`, encodeURIComponent(String(sequenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an MRI sequence with new data.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to update. mri_sequence : MRISequence     The updated MRI sequence data. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The updated MRI sequence.
         * @summary Update Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {BaseMRISequence} baseMRISequence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut: async (sequenceId: string, baseMRISequence: BaseMRISequence, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            assertParamExists('updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut', 'sequenceId', sequenceId)
            // verify required parameter 'baseMRISequence' is not null or undefined
            assertParamExists('updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut', 'baseMRISequence', baseMRISequence)
            const localVarPath = `/api/v1/exam/sequence/{sequence_id}`
                .replace(`{${"sequence_id"}}`, encodeURIComponent(String(sequenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseMRISequence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MriSequencesApi - functional programming interface
 * @export
 */
export const MriSequencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MriSequencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload an MRI sequence file and store it with the provided metadata.  Parameters ---------- mri_sequence : MRISequenceCreate     The MRI sequence metadata. file : UploadFile     The MRI sequence file to store. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The stored MRI sequence with the uploaded file.
         * @summary Create Mri Sequence
         * @param {File} file 
         * @param {string} name 
         * @param {string} [description] 
         * @param {string} [sequenceType] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMriSequenceApiV1ExamSequencePost(file: File, name: string, description?: string, sequenceType?: string, tags?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MRISequenceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMriSequenceApiV1ExamSequencePost(file, name, description, sequenceType, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.createMriSequenceApiV1ExamSequencePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to delete. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- None
         * @summary Delete Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all MRI sequences from the database.  Parameters ---------- database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- List[MRISequence]     The list of MRI sequences.
         * @summary Get All Mri Sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMriSequencesApiV1ExamSequencesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MRISequenceOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMriSequencesApiV1ExamSequencesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.getAllMriSequencesApiV1ExamSequencesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The retrieved MRI sequence.
         * @summary Get Mri Sequence By Id
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MRISequenceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.getMriSequenceByIdApiV1ExamSequenceSequenceIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an MRI sequence file by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. background_tasks : BackgroundTasks     The background tasks to run. name : str     The name of the file to download. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- FileResponse     The retrieved MRI sequence file.
         * @summary Get Mri Sequence File By Id
         * @param {string} sequenceId 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an MRI sequence with new data.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to update. mri_sequence : MRISequence     The updated MRI sequence data. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The updated MRI sequence.
         * @summary Update Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {BaseMRISequence} baseMRISequence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId: string, baseMRISequence: BaseMRISequence, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MRISequenceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId, baseMRISequence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MriSequencesApi.updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MriSequencesApi - factory interface
 * @export
 */
export const MriSequencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MriSequencesApiFp(configuration)
    return {
        /**
         * Upload an MRI sequence file and store it with the provided metadata.  Parameters ---------- mri_sequence : MRISequenceCreate     The MRI sequence metadata. file : UploadFile     The MRI sequence file to store. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The stored MRI sequence with the uploaded file.
         * @summary Create Mri Sequence
         * @param {File} file 
         * @param {string} name 
         * @param {string} [description] 
         * @param {string} [sequenceType] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMriSequenceApiV1ExamSequencePost(file: File, name: string, description?: string, sequenceType?: string, tags?: Array<string>, options?: any): AxiosPromise<MRISequenceOut> {
            return localVarFp.createMriSequenceApiV1ExamSequencePost(file, name, description, sequenceType, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to delete. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- None
         * @summary Delete Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all MRI sequences from the database.  Parameters ---------- database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- List[MRISequence]     The list of MRI sequences.
         * @summary Get All Mri Sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMriSequencesApiV1ExamSequencesAllGet(options?: any): AxiosPromise<Array<MRISequenceOut>> {
            return localVarFp.getAllMriSequencesApiV1ExamSequencesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The retrieved MRI sequence.
         * @summary Get Mri Sequence By Id
         * @param {string} sequenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId: string, options?: any): AxiosPromise<MRISequenceOut> {
            return localVarFp.getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an MRI sequence file by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. background_tasks : BackgroundTasks     The background tasks to run. name : str     The name of the file to download. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- FileResponse     The retrieved MRI sequence file.
         * @summary Get Mri Sequence File By Id
         * @param {string} sequenceId 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId: string, name?: string, options?: any): AxiosPromise<any> {
            return localVarFp.getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an MRI sequence with new data.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to update. mri_sequence : MRISequence     The updated MRI sequence data. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The updated MRI sequence.
         * @summary Update Mri Sequence Endpoint
         * @param {string} sequenceId 
         * @param {BaseMRISequence} baseMRISequence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId: string, baseMRISequence: BaseMRISequence, options?: any): AxiosPromise<MRISequenceOut> {
            return localVarFp.updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId, baseMRISequence, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MriSequencesApi - object-oriented interface
 * @export
 * @class MriSequencesApi
 * @extends {BaseAPI}
 */
export class MriSequencesApi extends BaseAPI {
    /**
     * Upload an MRI sequence file and store it with the provided metadata.  Parameters ---------- mri_sequence : MRISequenceCreate     The MRI sequence metadata. file : UploadFile     The MRI sequence file to store. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The stored MRI sequence with the uploaded file.
     * @summary Create Mri Sequence
     * @param {File} file 
     * @param {string} name 
     * @param {string} [description] 
     * @param {string} [sequenceType] 
     * @param {Array<string>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public createMriSequenceApiV1ExamSequencePost(file: File, name: string, description?: string, sequenceType?: string, tags?: Array<string>, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).createMriSequenceApiV1ExamSequencePost(file, name, description, sequenceType, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to delete. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- None
     * @summary Delete Mri Sequence Endpoint
     * @param {string} sequenceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId: string, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).deleteMriSequenceEndpointApiV1ExamSequenceSequenceIdDelete(sequenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all MRI sequences from the database.  Parameters ---------- database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- List[MRISequence]     The list of MRI sequences.
     * @summary Get All Mri Sequences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public getAllMriSequencesApiV1ExamSequencesAllGet(options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).getAllMriSequencesApiV1ExamSequencesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an MRI sequence by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The retrieved MRI sequence.
     * @summary Get Mri Sequence By Id
     * @param {string} sequenceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId: string, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).getMriSequenceByIdApiV1ExamSequenceSequenceIdGet(sequenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an MRI sequence file by its ID.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to retrieve. background_tasks : BackgroundTasks     The background tasks to run. name : str     The name of the file to download. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- FileResponse     The retrieved MRI sequence file.
     * @summary Get Mri Sequence File By Id
     * @param {string} sequenceId 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId: string, name?: string, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).getMriSequenceFileByIdApiV1ExamSequenceSequenceIdFileGet(sequenceId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an MRI sequence with new data.  Parameters ---------- sequence_id : str     The ID of the MRI sequence to update. mri_sequence : MRISequence     The updated MRI sequence data. database : AsyncIOMotorDatabase     The MongoDB database handle.  Returns ------- MRISequence     The updated MRI sequence.
     * @summary Update Mri Sequence Endpoint
     * @param {string} sequenceId 
     * @param {BaseMRISequence} baseMRISequence 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MriSequencesApi
     */
    public updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId: string, baseMRISequence: BaseMRISequence, options?: RawAxiosRequestConfig) {
        return MriSequencesApiFp(this.configuration).updateMriSequenceEndpointApiV1ExamSequenceSequenceIdPut(sequenceId, baseMRISequence, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResultsApi - axios parameter creator
 * @export
 */
export const ResultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a task result.  Parameters ---------- payload     Result pydantic input model  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Blank Result
         * @param {TaskId1} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlankResultApiV1ExamResultPost: async (taskId: TaskId1, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('createBlankResultApiV1ExamResultPost', 'taskId', taskId)
            const localVarPath = `/api/v1/exam/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (taskId !== undefined) {
                for (const [key, value] of Object.entries(taskId)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResultApiV1ExamResultResultIdDelete: async (resultId: ResultId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('deleteResultApiV1ExamResultResultIdDelete', 'resultId', resultId)
            const localVarPath = `/api/v1/exam/result/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing results of a certain task.  Parameters ---------- task_id     Id of parental task  Returns -------     List of task pydantic output model
         * @summary Get All Task Results
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskResultsApiV1ExamResultAllTaskIdGet: async (taskId: TaskId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getAllTaskResultsApiV1ExamResultAllTaskIdGet', 'taskId', taskId)
            const localVarPath = `/api/v1/exam/result/all/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Serve a DICOM instance.    - If it\'s already a DICOM Part-10 file → return FileResponse (supports HTTP Range).   - Else → convert to Part-10 in memory and return StreamingResponse.  Headers:   - \'application/dicom\' content type   - inline disposition (avoid forced download)   - \'Cache-Control: no-transform\' to prevent proxies from gzipping (which breaks Range offsets)
         * @summary Get DICOM result
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDicom: async (workflowId: string, taskId: string, resultId: string, filename: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getDicom', 'workflowId', workflowId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getDicom', 'taskId', taskId)
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getDicom', 'resultId', resultId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getDicom', 'filename', filename)
            const localVarPath = `/api/v1/exam/dcm/{workflow_id}/{task_id}/{result_id}/{filename}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MRD as binary stream.
         * @summary Get MRD (binary, interleaved float32 complex)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} ids IDs: \&#39;0,1,10-20,40-50:2\&#39;
         * @param {number} [coilIdx] Coil index
         * @param {number} [stride] Decimate samples by stride
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMRD: async (workflowId: string, taskId: string, resultId: string, ids: string, coilIdx?: number, stride?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getMRD', 'workflowId', workflowId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getMRD', 'taskId', taskId)
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getMRD', 'resultId', resultId)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getMRD', 'ids', ids)
            const localVarPath = `/api/v1/exam/mrd/{workflow_id}/{task_id}/{result_id}/data`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (coilIdx !== undefined) {
                localVarQueryParameter['coil_idx'] = coilIdx;
            }

            if (stride !== undefined) {
                localVarQueryParameter['stride'] = stride;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MRD meta info.
         * @summary Get ISMRMRD metadata (indexed acquisitions)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMrdMeta: async (workflowId: string, taskId: string, resultId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getMrdMeta', 'workflowId', workflowId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getMrdMeta', 'taskId', taskId)
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getMrdMeta', 'resultId', resultId)
            const localVarPath = `/api/v1/exam/mrd/{workflow_id}/{task_id}/{result_id}/meta`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing result.  Parameters ---------- result_id     Id of the result to be returned  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResultApiV1ExamResultResultIdGet: async (resultId: ResultId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getResultApiV1ExamResultResultIdGet', 'resultId', resultId)
            const localVarPath = `/api/v1/exam/result/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing result.  Parameters ---------- result_id     Id of the result to be updated payload     Result pydantic base model/dict     If this is the pydantic ResultBase model, only fields in the base model can be updated.  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Set Result
         * @param {ResultId} resultId 
         * @param {SetResult} setResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResultApiV1ExamResultResultIdPut: async (resultId: ResultId, setResult: SetResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('setResultApiV1ExamResultResultIdPut', 'resultId', resultId)
            // verify required parameter 'setResult' is not null or undefined
            assertParamExists('setResultApiV1ExamResultResultIdPut', 'setResult', setResult)
            const localVarPath = `/api/v1/exam/result/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResultsApi - functional programming interface
 * @export
 */
export const ResultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResultsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a task result.  Parameters ---------- payload     Result pydantic input model  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Blank Result
         * @param {TaskId1} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBlankResultApiV1ExamResultPost(taskId: TaskId1, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBlankResultApiV1ExamResultPost(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.createBlankResultApiV1ExamResultPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResultApiV1ExamResultResultIdDelete(resultId: ResultId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResultApiV1ExamResultResultIdDelete(resultId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.deleteResultApiV1ExamResultResultIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing results of a certain task.  Parameters ---------- task_id     Id of parental task  Returns -------     List of task pydantic output model
         * @summary Get All Task Results
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResultOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.getAllTaskResultsApiV1ExamResultAllTaskIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Serve a DICOM instance.    - If it\'s already a DICOM Part-10 file → return FileResponse (supports HTTP Range).   - Else → convert to Part-10 in memory and return StreamingResponse.  Headers:   - \'application/dicom\' content type   - inline disposition (avoid forced download)   - \'Cache-Control: no-transform\' to prevent proxies from gzipping (which breaks Range offsets)
         * @summary Get DICOM result
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDicom(workflowId: string, taskId: string, resultId: string, filename: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDicom(workflowId, taskId, resultId, filename, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.getDicom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get MRD as binary stream.
         * @summary Get MRD (binary, interleaved float32 complex)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} ids IDs: \&#39;0,1,10-20,40-50:2\&#39;
         * @param {number} [coilIdx] Coil index
         * @param {number} [stride] Decimate samples by stride
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMRD(workflowId: string, taskId: string, resultId: string, ids: string, coilIdx?: number, stride?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMRD(workflowId, taskId, resultId, ids, coilIdx, stride, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.getMRD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get MRD meta info.
         * @summary Get ISMRMRD metadata (indexed acquisitions)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMrdMeta(workflowId: string, taskId: string, resultId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MRDMetaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMrdMeta(workflowId, taskId, resultId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.getMrdMeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an existing result.  Parameters ---------- result_id     Id of the result to be returned  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResultApiV1ExamResultResultIdGet(resultId: ResultId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResultApiV1ExamResultResultIdGet(resultId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.getResultApiV1ExamResultResultIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing result.  Parameters ---------- result_id     Id of the result to be updated payload     Result pydantic base model/dict     If this is the pydantic ResultBase model, only fields in the base model can be updated.  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Set Result
         * @param {ResultId} resultId 
         * @param {SetResult} setResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setResultApiV1ExamResultResultIdPut(resultId: ResultId, setResult: SetResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setResultApiV1ExamResultResultIdPut(resultId, setResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.setResultApiV1ExamResultResultIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResultsApi - factory interface
 * @export
 */
export const ResultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResultsApiFp(configuration)
    return {
        /**
         * Create a task result.  Parameters ---------- payload     Result pydantic input model  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Blank Result
         * @param {TaskId1} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlankResultApiV1ExamResultPost(taskId: TaskId1, options?: any): AxiosPromise<ResultOut> {
            return localVarFp.createBlankResultApiV1ExamResultPost(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResultApiV1ExamResultResultIdDelete(resultId: ResultId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteResultApiV1ExamResultResultIdDelete(resultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing results of a certain task.  Parameters ---------- task_id     Id of parental task  Returns -------     List of task pydantic output model
         * @summary Get All Task Results
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId: TaskId, options?: any): AxiosPromise<Array<ResultOut>> {
            return localVarFp.getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Serve a DICOM instance.    - If it\'s already a DICOM Part-10 file → return FileResponse (supports HTTP Range).   - Else → convert to Part-10 in memory and return StreamingResponse.  Headers:   - \'application/dicom\' content type   - inline disposition (avoid forced download)   - \'Cache-Control: no-transform\' to prevent proxies from gzipping (which breaks Range offsets)
         * @summary Get DICOM result
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDicom(workflowId: string, taskId: string, resultId: string, filename: string, options?: any): AxiosPromise<any> {
            return localVarFp.getDicom(workflowId, taskId, resultId, filename, options).then((request) => request(axios, basePath));
        },
        /**
         * Get MRD as binary stream.
         * @summary Get MRD (binary, interleaved float32 complex)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {string} ids IDs: \&#39;0,1,10-20,40-50:2\&#39;
         * @param {number} [coilIdx] Coil index
         * @param {number} [stride] Decimate samples by stride
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMRD(workflowId: string, taskId: string, resultId: string, ids: string, coilIdx?: number, stride?: number, options?: any): AxiosPromise<any> {
            return localVarFp.getMRD(workflowId, taskId, resultId, ids, coilIdx, stride, options).then((request) => request(axios, basePath));
        },
        /**
         * Get MRD meta info.
         * @summary Get ISMRMRD metadata (indexed acquisitions)
         * @param {string} workflowId 
         * @param {string} taskId 
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMrdMeta(workflowId: string, taskId: string, resultId: string, options?: any): AxiosPromise<MRDMetaResponse> {
            return localVarFp.getMrdMeta(workflowId, taskId, resultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing result.  Parameters ---------- result_id     Id of the result to be returned  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Result
         * @param {ResultId} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResultApiV1ExamResultResultIdGet(resultId: ResultId, options?: any): AxiosPromise<ResultOut> {
            return localVarFp.getResultApiV1ExamResultResultIdGet(resultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing result.  Parameters ---------- result_id     Id of the result to be updated payload     Result pydantic base model/dict     If this is the pydantic ResultBase model, only fields in the base model can be updated.  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Set Result
         * @param {ResultId} resultId 
         * @param {SetResult} setResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResultApiV1ExamResultResultIdPut(resultId: ResultId, setResult: SetResult, options?: any): AxiosPromise<ResultOut> {
            return localVarFp.setResultApiV1ExamResultResultIdPut(resultId, setResult, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResultsApi - object-oriented interface
 * @export
 * @class ResultsApi
 * @extends {BaseAPI}
 */
export class ResultsApi extends BaseAPI {
    /**
     * Create a task result.  Parameters ---------- payload     Result pydantic input model  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Blank Result
     * @param {TaskId1} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public createBlankResultApiV1ExamResultPost(taskId: TaskId1, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).createBlankResultApiV1ExamResultPost(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Delete Result
     * @param {ResultId} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public deleteResultApiV1ExamResultResultIdDelete(resultId: ResultId, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).deleteResultApiV1ExamResultResultIdDelete(resultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing results of a certain task.  Parameters ---------- task_id     Id of parental task  Returns -------     List of task pydantic output model
     * @summary Get All Task Results
     * @param {TaskId} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getAllTaskResultsApiV1ExamResultAllTaskIdGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Serve a DICOM instance.    - If it\'s already a DICOM Part-10 file → return FileResponse (supports HTTP Range).   - Else → convert to Part-10 in memory and return StreamingResponse.  Headers:   - \'application/dicom\' content type   - inline disposition (avoid forced download)   - \'Cache-Control: no-transform\' to prevent proxies from gzipping (which breaks Range offsets)
     * @summary Get DICOM result
     * @param {string} workflowId 
     * @param {string} taskId 
     * @param {string} resultId 
     * @param {string} filename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public getDicom(workflowId: string, taskId: string, resultId: string, filename: string, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getDicom(workflowId, taskId, resultId, filename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get MRD as binary stream.
     * @summary Get MRD (binary, interleaved float32 complex)
     * @param {string} workflowId 
     * @param {string} taskId 
     * @param {string} resultId 
     * @param {string} ids IDs: \&#39;0,1,10-20,40-50:2\&#39;
     * @param {number} [coilIdx] Coil index
     * @param {number} [stride] Decimate samples by stride
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public getMRD(workflowId: string, taskId: string, resultId: string, ids: string, coilIdx?: number, stride?: number, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getMRD(workflowId, taskId, resultId, ids, coilIdx, stride, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get MRD meta info.
     * @summary Get ISMRMRD metadata (indexed acquisitions)
     * @param {string} workflowId 
     * @param {string} taskId 
     * @param {string} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public getMrdMeta(workflowId: string, taskId: string, resultId: string, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getMrdMeta(workflowId, taskId, resultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing result.  Parameters ---------- result_id     Id of the result to be returned  Returns -------     Result pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Get Result
     * @param {ResultId} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public getResultApiV1ExamResultResultIdGet(resultId: ResultId, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getResultApiV1ExamResultResultIdGet(resultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing result.  Parameters ---------- result_id     Id of the result to be updated payload     Result pydantic base model/dict     If this is the pydantic ResultBase model, only fields in the base model can be updated.  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Set Result
     * @param {ResultId} resultId 
     * @param {SetResult} setResult 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public setResultApiV1ExamResultResultIdPut(resultId: ResultId, setResult: SetResult, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).setResultApiV1ExamResultResultIdPut(resultId, setResult, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskApiV1ExamTaskNewPost: async (payload: Payload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createTaskApiV1ExamTaskNewPost', 'payload', payload)
            const localVarPath = `/api/v1/exam/task/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task From Template
         * @param {string} workflowId 
         * @param {string} templateId 
         * @param {boolean} newTaskIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskFromTemplateApiV1ExamTaskPost: async (workflowId: string, templateId: string, newTaskIsTemplate: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('createTaskFromTemplateApiV1ExamTaskPost', 'workflowId', workflowId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('createTaskFromTemplateApiV1ExamTaskPost', 'templateId', templateId)
            // verify required parameter 'newTaskIsTemplate' is not null or undefined
            assertParamExists('createTaskFromTemplateApiV1ExamTaskPost', 'newTaskIsTemplate', newTaskIsTemplate)
            const localVarPath = `/api/v1/exam/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (workflowId !== undefined) {
                localVarQueryParameter['workflow_id'] = workflowId;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }

            if (newTaskIsTemplate !== undefined) {
                localVarQueryParameter['new_task_is_template'] = newTaskIsTemplate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskApiV1ExamTaskTaskIdDelete: async (taskId: TaskId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('deleteTaskApiV1ExamTaskTaskIdDelete', 'taskId', taskId)
            const localVarPath = `/api/v1/exam/task/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing task templates.  Returns -------     List of task pydantic output model
         * @summary Get All Task Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/task/templates/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
         * @summary Get All Workflow Tasks
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet: async (workflowId: WorkflowId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/exam/task/all/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskApiV1ExamTaskTaskIdGet: async (taskId: TaskId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTaskApiV1ExamTaskTaskIdGet', 'taskId', taskId)
            const localVarPath = `/api/v1/exam/task/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Task
         * @param {TaskId} taskId 
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskApiV1ExamTaskTaskIdPut: async (taskId: TaskId, payload: Payload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('updateTaskApiV1ExamTaskTaskIdPut', 'taskId', taskId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateTaskApiV1ExamTaskTaskIdPut', 'payload', payload)
            const localVarPath = `/api/v1/exam/task/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskApiV1ExamTaskNewPost(payload: Payload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateTaskApiV1ExamTaskNewPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskApiV1ExamTaskNewPost(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.createTaskApiV1ExamTaskNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task From Template
         * @param {string} workflowId 
         * @param {string} templateId 
         * @param {boolean} newTaskIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskFromTemplateApiV1ExamTaskPost(workflowId: string, templateId: string, newTaskIsTemplate: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateTaskFromTemplateApiV1ExamTaskPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskFromTemplateApiV1ExamTaskPost(workflowId, templateId, newTaskIsTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.createTaskFromTemplateApiV1ExamTaskPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskApiV1ExamTaskTaskIdDelete(taskId: TaskId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskApiV1ExamTaskTaskIdDelete(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.deleteTaskApiV1ExamTaskTaskIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing task templates.  Returns -------     List of task pydantic output model
         * @summary Get All Task Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
         * @summary Get All Workflow Tasks
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskApiV1ExamTaskTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetTaskApiV1ExamTaskTaskIdGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskApiV1ExamTaskTaskIdGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getTaskApiV1ExamTaskTaskIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Task
         * @param {TaskId} taskId 
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaskApiV1ExamTaskTaskIdPut(taskId: TaskId, payload: Payload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUpdateTaskApiV1ExamTaskTaskIdPut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaskApiV1ExamTaskTaskIdPut(taskId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.updateTaskApiV1ExamTaskTaskIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskApiV1ExamTaskNewPost(payload: Payload, options?: any): AxiosPromise<ResponseCreateTaskApiV1ExamTaskNewPost> {
            return localVarFp.createTaskApiV1ExamTaskNewPost(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Task From Template
         * @param {string} workflowId 
         * @param {string} templateId 
         * @param {boolean} newTaskIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskFromTemplateApiV1ExamTaskPost(workflowId: string, templateId: string, newTaskIsTemplate: boolean, options?: any): AxiosPromise<ResponseCreateTaskFromTemplateApiV1ExamTaskPost> {
            return localVarFp.createTaskFromTemplateApiV1ExamTaskPost(workflowId, templateId, newTaskIsTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskApiV1ExamTaskTaskIdDelete(taskId: TaskId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTaskApiV1ExamTaskTaskIdDelete(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing task templates.  Returns -------     List of task pydantic output model
         * @summary Get All Task Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options?: any): AxiosPromise<Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>> {
            return localVarFp.getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
         * @summary Get All Workflow Tasks
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId: WorkflowId, options?: any): AxiosPromise<Array<GetAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet200ResponseInner>> {
            return localVarFp.getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Task
         * @param {TaskId} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskApiV1ExamTaskTaskIdGet(taskId: TaskId, options?: any): AxiosPromise<ResponseGetTaskApiV1ExamTaskTaskIdGet> {
            return localVarFp.getTaskApiV1ExamTaskTaskIdGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Task
         * @param {TaskId} taskId 
         * @param {Payload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskApiV1ExamTaskTaskIdPut(taskId: TaskId, payload: Payload, options?: any): AxiosPromise<ResponseUpdateTaskApiV1ExamTaskTaskIdPut> {
            return localVarFp.updateTaskApiV1ExamTaskTaskIdPut(taskId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Create a new task.  Parameters ---------- payload     Task pydantic input model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Task
     * @param {Payload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public createTaskApiV1ExamTaskNewPost(payload: Payload, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).createTaskApiV1ExamTaskNewPost(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new task from template.  Parameters ---------- workflow_id     ID of the workflow, the task is related to template_id     ID of the template, the task is created from new_task_is_template     set the is_template property on the new task  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Task From Template
     * @param {string} workflowId 
     * @param {string} templateId 
     * @param {boolean} newTaskIsTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public createTaskFromTemplateApiV1ExamTaskPost(workflowId: string, templateId: string, newTaskIsTemplate: boolean, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).createTaskFromTemplateApiV1ExamTaskPost(workflowId, templateId, newTaskIsTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a task.  Parameters ---------- task_id     Id of the task to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Delete Task
     * @param {TaskId} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTaskApiV1ExamTaskTaskIdDelete(taskId: TaskId, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).deleteTaskApiV1ExamTaskTaskIdDelete(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing task templates.  Returns -------     List of task pydantic output model
     * @summary Get All Task Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getAllTaskTemplatesApiV1ExamTaskTemplatesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing tasks of a certain workflow.  Parameters ---------- workflow_id     Id of parental workflow  Returns -------     List of task pydantic output model
     * @summary Get All Workflow Tasks
     * @param {WorkflowId} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getAllWorkflowTasksApiV1ExamTaskAllWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing task.  Parameters ---------- task_id     Id of the task to be returned  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Get Task
     * @param {TaskId} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTaskApiV1ExamTaskTaskIdGet(taskId: TaskId, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTaskApiV1ExamTaskTaskIdGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing task.  Parameters ---------- task_id     Id of the workflow to be updated payload     Task pydantic base model  Returns -------     Task pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Task
     * @param {TaskId} taskId 
     * @param {Payload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public updateTaskApiV1ExamTaskTaskIdPut(taskId: TaskId, payload: Payload, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).updateTaskApiV1ExamTaskTaskIdPut(taskId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowApiV1ExamWorkflowNewPost: async (baseWorkflow: BaseWorkflow, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseWorkflow' is not null or undefined
            assertParamExists('createWorkflowApiV1ExamWorkflowNewPost', 'baseWorkflow', baseWorkflow)
            const localVarPath = `/api/v1/exam/workflow/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseWorkflow, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow From Template
         * @param {string} examId 
         * @param {string} templateId 
         * @param {boolean} newWorkflowIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowFromTemplateApiV1ExamWorkflowPost: async (examId: string, templateId: string, newWorkflowIsTemplate: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('createWorkflowFromTemplateApiV1ExamWorkflowPost', 'examId', examId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('createWorkflowFromTemplateApiV1ExamWorkflowPost', 'templateId', templateId)
            // verify required parameter 'newWorkflowIsTemplate' is not null or undefined
            assertParamExists('createWorkflowFromTemplateApiV1ExamWorkflowPost', 'newWorkflowIsTemplate', newWorkflowIsTemplate)
            const localVarPath = `/api/v1/exam/workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (examId !== undefined) {
                localVarQueryParameter['exam_id'] = examId;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }

            if (newWorkflowIsTemplate !== undefined) {
                localVarQueryParameter['new_workflow_is_template'] = newWorkflowIsTemplate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete: async (workflowId: WorkflowId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete', 'workflowId', workflowId)
            const localVarPath = `/api/v1/exam/workflow/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
         * @summary Get All Exam Workflows
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet: async (examId: ExamId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet', 'examId', examId)
            const localVarPath = `/api/v1/exam/workflow/all/{exam_id}`
                .replace(`{${"exam_id"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all workflow templates.  Returns -------     List of workflow pydantic output model
         * @summary Get All Workflow Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exam/workflow/templates/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowApiV1ExamWorkflowWorkflowIdGet: async (workflowId: WorkflowId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowApiV1ExamWorkflowWorkflowIdGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/exam/workflow/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Workflow
         * @param {WorkflowId} workflowId 
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowApiV1ExamWorkflowWorkflowIdPut: async (workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('updateWorkflowApiV1ExamWorkflowWorkflowIdPut', 'workflowId', workflowId)
            // verify required parameter 'baseWorkflow' is not null or undefined
            assertParamExists('updateWorkflowApiV1ExamWorkflowWorkflowIdPut', 'baseWorkflow', baseWorkflow)
            const localVarPath = `/api/v1/exam/workflow/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseWorkflow, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflowApiV1ExamWorkflowNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow From Template
         * @param {string} examId 
         * @param {string} templateId 
         * @param {boolean} newWorkflowIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowFromTemplateApiV1ExamWorkflowPost(examId: string, templateId: string, newWorkflowIsTemplate: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowFromTemplateApiV1ExamWorkflowPost(examId, templateId, newWorkflowIsTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflowFromTemplateApiV1ExamWorkflowPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId: WorkflowId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
         * @summary Get All Exam Workflows
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all workflow templates.  Returns -------     List of workflow pydantic output model
         * @summary Get All Workflow Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getWorkflowApiV1ExamWorkflowWorkflowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Workflow
         * @param {WorkflowId} workflowId 
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId, baseWorkflow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.updateWorkflowApiV1ExamWorkflowWorkflowIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow: BaseWorkflow, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
         * @summary Create Workflow From Template
         * @param {string} examId 
         * @param {string} templateId 
         * @param {boolean} newWorkflowIsTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowFromTemplateApiV1ExamWorkflowPost(examId: string, templateId: string, newWorkflowIsTemplate: boolean, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.createWorkflowFromTemplateApiV1ExamWorkflowPost(examId, templateId, newWorkflowIsTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
         * @summary Delete Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId: WorkflowId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
         * @summary Get All Exam Workflows
         * @param {ExamId} examId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId: ExamId, options?: any): AxiosPromise<Array<WorkflowOut>> {
            return localVarFp.getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all workflow templates.  Returns -------     List of workflow pydantic output model
         * @summary Get All Workflow Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options?: any): AxiosPromise<Array<WorkflowOut>> {
            return localVarFp.getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Get Workflow
         * @param {WorkflowId} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId: WorkflowId, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
         * @summary Update Workflow
         * @param {WorkflowId} workflowId 
         * @param {BaseWorkflow} baseWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options?: any): AxiosPromise<WorkflowOut> {
            return localVarFp.updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId, baseWorkflow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * Create new workflow.  Parameters ---------- payload     Workflow pydantic input model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Workflow
     * @param {BaseWorkflow} baseWorkflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflowApiV1ExamWorkflowNewPost(baseWorkflow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new workflow from template.  Parameters ---------- exam_id     Id of the exam, the workflow is related to template_id     ID of the template, the workflow is created from new_workflow_is_template     set the is_template property of the new workflow and its tasks  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Creation unsuccessful
     * @summary Create Workflow From Template
     * @param {string} examId 
     * @param {string} templateId 
     * @param {boolean} newWorkflowIsTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowFromTemplateApiV1ExamWorkflowPost(examId: string, templateId: string, newWorkflowIsTemplate: boolean, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflowFromTemplateApiV1ExamWorkflowPost(examId, templateId, newWorkflowIsTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workflow. Cascade delete the associated tasks.  Parameters ---------- workflow_id     Id of the workflow to be deleted  Raises ------ HTTPException     404: Not found
     * @summary Delete Workflow
     * @param {WorkflowId} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId: WorkflowId, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).deleteWorkflowApiV1ExamWorkflowWorkflowIdDelete(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing workflows of a certain exam.  Parameters ---------- exam_id     Id of parent exam  Returns -------     List of workflow pydantic output model
     * @summary Get All Exam Workflows
     * @param {ExamId} examId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId: ExamId, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getAllExamWorkflowsApiV1ExamWorkflowAllExamIdGet(examId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all workflow templates.  Returns -------     List of workflow pydantic output model
     * @summary Get All Workflow Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getAllWorkflowTemplatesApiV1ExamWorkflowTemplatesAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a workflow.  Parameters ---------- workflow_id     Id of the workflow to be returned  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Get Workflow
     * @param {WorkflowId} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId: WorkflowId, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowApiV1ExamWorkflowWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing workflow.  Parameters ---------- workflow_id     Id of the workflow to be updated payload     Workflow pydantic indput model  Returns -------     Workflow pydantic output model  Raises ------ HTTPException     404: Not found
     * @summary Update Workflow
     * @param {WorkflowId} workflowId 
     * @param {BaseWorkflow} baseWorkflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId: WorkflowId, baseWorkflow: BaseWorkflow, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).updateWorkflowApiV1ExamWorkflowWorkflowIdPut(workflowId, baseWorkflow, options).then((request) => request(this.axios, this.basePath));
    }
}



